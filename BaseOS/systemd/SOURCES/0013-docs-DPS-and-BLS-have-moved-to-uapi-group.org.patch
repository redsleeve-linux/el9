From 3c3d99309e5e8dfd1c6a7c48dc3810e30b77fefc Mon Sep 17 00:00:00 2001
From: Luca Boccassi <bluca@debian.org>
Date: Tue, 1 Nov 2022 21:55:23 +0000
Subject: [PATCH] docs: DPS and BLS have moved to uapi-group.org

(cherry picked from commit 729a49288153d341d5c4edd5d701421bb766135c)

Related #2138081
---
 docs/BOOT_LOADER_SPECIFICATION.md | 745 +-----------------------------
 docs/DISCOVERABLE_PARTITIONS.md   | 424 +----------------
 2 files changed, 2 insertions(+), 1167 deletions(-)

diff --git a/docs/BOOT_LOADER_SPECIFICATION.md b/docs/BOOT_LOADER_SPECIFICATION.md
index 9188033768..33066b2875 100644
--- a/docs/BOOT_LOADER_SPECIFICATION.md
+++ b/docs/BOOT_LOADER_SPECIFICATION.md
@@ -1,744 +1 @@
----
-title: Boot Loader Specification
-category: Booting
-layout: default
-SPDX-License-Identifier: LGPL-2.1-or-later
----
-
-# The Boot Loader Specification
-
-This document defines a set of file formats and naming conventions that allow
-the boot loader menu entries to be shared between multiple operating systems
-and boot loaders installed on one device.
-
-Operating systems cooperatively manage boot loader menu entry directories that
-contain drop-in files, making multi-boot scenarios easy to support. Boot menu
-entries are defined via two simple formats that can be understood by different
-boot loader implementations, operating systems, and userspace programs. The
-same scheme can be used to prepare OS media for cases where the firmware
-includes a boot loader.
-
-## Target Audience
-
-The target audience for this specification is:
-
-* Boot loader developers, to write a boot loader that directly reads its
-  menu entries from these files
-* Firmware developers, to add generic boot loading support directly to the
-  firmware itself
-* OS installer developers, to create appropriate partitions and set up the
-  initial boot loader menu entries
-* Distribution developers, to create appropriate menu entry snippets when
-  installing or updating kernel packages
-* UI developers, to implement user interfaces that list and select among the
-  available boot options
-
-## The Partitions
-
-Everything described below is located on one or two partitions. The boot loader
-or user-space programs reading the boot loader menu entries should locate them
-in the following manner:
-
-* On disks with an MBR partition table:
-
-  * The boot partition — a partition with the type ID of `0xEA` — shall be used
-    as the single location for boot loader menu entries.
-
-* On disks with GPT (GUID Partition Table)
-
-  * The EFI System Partition (ESP for short) — a partition with a GPT type GUID
-    of `c12a7328-f81f-11d2-ba4b-00a0c93ec93b` — may be used as one of two locations for
-    boot loader menu entries.
-
-  * Optionally, an Extended Boot Loader Partition (XBOOTLDR partition for
-    short) — a partition with GPT type GUID of
-    `bc13c2ff-59e6-4262-a352-b275fd6f7172` — may be used as the second of two
-    locations for boot loader menu entries. This partition must be located on
-    the same disk as the ESP.
-
-There may be at most one partition of each of the types listed above on the
-same disk.
-
-**Note:** _These partitions are **shared** among all OS installations on the
-same disk. Instead of maintaining one boot partition per installed OS (as
-`/boot/` was traditionally handled), all installed OSes use the same place for
-boot loader menu entries._
-
-For systems where the firmware is able to read file systems directly, the ESP
-must — and the MBR boot and GPT XBOOTLDR partition should — be a file system
-readable by the firmware. For most systems this means VFAT (16 or 32
-bit). Applications accessing both partitions should hence not assume that
-fancier file system features such as symlinks, hardlinks, access control or
-case sensitivity are supported.
-
-### The `$BOOT` Partition Placeholder
-
-In the text below, the placeholder `$BOOT` will be used to refer to the
-partition determined as follows:
-
- 1. On disks with an MBR partition table: → the boot partition, as described above
-
- 2. On disks with a GPT partition table: → the XBOOTLDR partition if it exists
-
- 3. Otherwise, on disks with a GPT partition table: → the ESP
-
-`$BOOT` is the *primary* place to put boot menu entry resources into, but
-typically not the only one. Most importantly, boot loaders should also pick up
-menu entries from the ESP, even if XBOOTLDR exists (for details see below).
-
-### Creating These Partitions
-
-An installer for an operating system should use this logic when selecting or
-creating partitions:
-
-  * If a boot partition (in case of MBR) or an XBOOTLDR partition (in case of
-    GPT) already exists it should be used as `$BOOT` and used as primary
-    location to place boot loader menu resources in.
-
-  * Otherwise, if on GPT and an ESP is found and it is large enough (let's say
-    at least 1G) it should be used as `$BOOT` and used as primary location to
-    place boot loader menu resources in.
-
-  * Otherwise, if on GPT and neither XBOOTLDR nor ESP exist, an ESP should be
-    created of the appropriate size and be used as `$BOOT`, and used as primary
-    location to place boot loader menu resources in.
-
-  * Otherwise, a boot partition (in case of MBR) or XBOOTLDR partition (in case
-    of GPT) should be created of an appropriate size, and be used as `$BOOT`,
-    and used as primary location to place boot loader menu resources in.
-
-These partitions shall be determined during _installation time_, and
-`/etc/fstab` entries may be created.
-
-### Mount Points
-
-It is recommended to mount `$BOOT` to `/boot/`, and the ESP to `/efi/`. If
-`$BOOT` and the ESP are the same, then either a bind mount or a symlink should
-be established making the partition available under both paths.
-
-(Mounting the ESP to `/boot/efi/`, as was traditionally done, is not
-recommended. Such a nested setup complicates an implementation via direct
-`autofs` mounts — as implemented by `systemd` for example —, as establishing
-the inner `autofs` will trigger the outer one. Mounting the two partitions via
-`autofs` is recommended because the simple VFAT file system has weak data
-integrity properties and should remain unmounted whenever possible.)
-
-## Boot Loader Entries
-
-This specification defines two types of boot loader entries. The first type is
-text based, very simple, and suitable for a variety of firmware, architecture
-and image types ("Type #1"). The second type is specific to EFI, but allows
-single-file images that embed all metadata in the kernel binary itself, which
-is useful to cryptographically sign them as one file for the purpose of
-SecureBoot ("Type #2").
-
-Not all boot loader entries will apply to all systems. For example, Type #1
-entries that use the `efi` key and all Type #2 entries only apply to EFI
-systems. Entries using the `architecture` key might specify an architecture that
-doesn't match the local one. Boot loaders should ignore all entries that don't
-match the local platform and what the boot loader can support, and hide them
-from the user. Only entries matching the feature set of boot loader and system
-shall be considered and displayed. This allows image builders to put together
-images that transparently support multiple different architectures.
-
-Note that the three partitions described above are not supposed to be the
-exclusive territory of this specification. This specification only defines
-semantics of the `/loader/entries/` directory (along with the companion file
-`/loader/entries.srel`) and the `/EFI/Linux/` directory inside the file system,
-but it doesn't intend to define contents of the rest of the file system. Boot
-loaders, firmware, and other software implementing this specification may
-choose to place other files and directories in the same file system. For
-example, boot loaders that implement this specification might install their own
-boot code on the same partition; this is particularly common in the case of the
-ESP. Implementations of this specification must be able to operate correctly if
-files or directories other than `/loader/entries/` and `/EFI/Linux/` are found
-in the top level directory. Implementations that add their own files or
-directories to the file systems should use well-named directories, to make name
-collisions between multiple users of the file system unlikely.
-
-### Type #1 Boot Loader Specification Entries
-
-`/loader/entries/` in `$BOOT` is the primary directory containing Type #1
-drop-in snippets defining boot entries, one `.conf` file for each boot menu
-item. Each OS may provide one or more such entries.
-
-If the ESP is separate from `$BOOT` it may also contain a `/loader/entries/`
-directory, where the boot loader should look for boot entry snippets, as an
-additional source. The boot loader should enumerate both directories and
-present a merged list to the user. Note that this is done for compatibility
-only: while boot loaders should look in both places, OSes should only add their
-files to `$BOOT`.
-
-**Note:** _In all cases the `/loader/entries/` directory should be located
-directly in the root of the file system. Specifically, the `/loader/entries/`
-directory should **not** be located under the `/EFI/` subdirectory on the ESP._
-
-The file name of the boot entry snippets is used for identification of the boot
-item but shall never be presented to the user in the UI. The file name may be
-chosen freely but should be unique enough to avoid clashes between OS
-installations. More specifically, it is suggested to include the `entry-token`
-(see
-[kernel-install](https://www.freedesktop.org/software/systemd/man/kernel-install.html))
-or machine ID (see
-[/etc/machine-id](https://www.freedesktop.org/software/systemd/man/machine-id.html)),
-and the kernel version (as returned by `uname -r`, including the OS
-identifier), so that the whole filename is
-`$BOOT/loader/entries/<entry-token-or-machine-id>-<version>.conf`.
-
-Example: `$BOOT/loader/entries/6a9857a393724b7a981ebb5b8495b9ea-3.8.0-2.fc19.x86_64.conf`.
-
-In order to maximize compatibility with file system implementations and
-restricted boot loader environments, and to minimize conflicting character use
-with other programs, file names shall be chosen from a restricted character
-set: ASCII upper and lower case characters, digits, "+", "-", "_" and ".".
-Also, the file names should have a length of at least one and at most 255
-characters (including the file name suffix).
-
-These boot loader menu snippets shall be UNIX-style text files (i.e. lines
-separated by a single newline character), in the UTF-8 encoding. The
-boot loader menu snippets are loosely inspired by Grub1's configuration syntax.
-Lines beginning with "#" are used for comments and shall be ignored. The first
-word of a line is used as key and is separated by one or more spaces from the
-value.
-
-#### Type #1 Boot Loader Entry Keys
-
-The following keys are recognized:
-
-* `title` is a human-readable title for this menu item to be displayed in the
-  boot menu. It is a good idea to initialize this from the `PRETTY_NAME=` of
-  [os-release](https://www.freedesktop.org/software/systemd/man/os-release.html).
-  This name should be descriptive and does not have to be unique. If a boot
-  loader discovers two entries with the same title it should show more than
-  just the raw title in the UI, for example by appending the `version`
-  field. This field is optional.
-
-  Example: `title Fedora 18 (Spherical Cow)`
-
-* `version` is a human-readable version for this menu item. This is usually the
-  kernel version and is intended for use by OSes to install multiple kernel
-  versions with the same `title` field. This field is used for sorting entries,
-  so that the boot loader can order entries by age or select the newest one
-  automatically. This field is optional.
-
-  See [Sorting](#sorting) below.
-
-  Example: `version 3.7.2-201.fc18.x86_64`
-
-* `machine-id` is the machine ID of the OS. This can be used by boot loaders
-  and applications to filter out boot entries, for example to show only a
-  single newest kernel per OS, to group items by OS, or to filter out the
-  currently booted OS when showing only other installed operating systems.
-  This ID shall be formatted as 32 lower case hexadecimal characters
-  (i.e. without any UUID formatting). This key is optional.
-
-  Example: `machine-id 4098b3f648d74c13b1f04ccfba7798e8`
-
-* `sort-key` is a short string used for sorting entries on display. This should
-  typically be initialized from the `IMAGE_ID=` or `ID=` fields of
-  [os-release](https://www.freedesktop.org/software/systemd/man/os-release.html),
-  possibly with an additional suffix. This field is optional.
-
-  Example: `sort-key fedora`
-
-* `linux` is the Linux kernel image to execute and takes a path relative to the
-  root of the file system containing the boot entry snippet itself. It is
-  recommended that every distribution creates an entry-token/machine-id and
-  version specific subdirectory and places its kernels and initrd images there
-  (see below).
-
-  Example: `linux /6a9857a393724b7a981ebb5b8495b9ea/3.8.0-2.fc19.x86_64/linux`
-
-* `initrd` is the initrd `cpio` image to use when executing the kernel. This key
-  may appear more than once in which case all specified images are used, in the
-  order they are listed.
-
-  Example: `initrd 6a9857a393724b7a981ebb5b8495b9ea/3.8.0-2.fc19.x86_64/initrd`
-
-* `efi` refers to an arbitrary EFI program. If this key is set, and the system
-  is not an EFI system, this entry should be hidden.
-
-* `options` shall contain kernel parameters to pass to the Linux kernel to
-  spawn. This key is optional and may appear more than once in which case all
-  specified parameters are combined in the order they are listed.
-
-  Example: `options root=UUID=6d3376e4-fc93-4509-95ec-a21d68011da2 quiet`
-
-* `devicetree` refers to the binary device tree to use when executing the
-  kernel. This key is optional.
-
-  Example: `devicetree 6a9857a393724b7a981ebb5b8495b9ea/3.8.0-2.fc19.armv7hl/tegra20-paz00.dtb`
-
-* `devicetree-overlay` refers to a list of device tree overlays that should be
-  applied by the boot loader. Multiple overlays are separated by spaces and
-  applied in the same order as they are listed. This key is optional but
-  depends on the `devicetree` key.
-
-  Example: `devicetree-overlay /6a9857a393724b7a981ebb5b8495b9ea/overlays/overlay_A.dtbo /6a9857a393724b7a981ebb5b8495b9ea/overlays/overlay_B.dtbo`
-
-* `architecture` refers to the architecture this entry is for. The argument
-  should be an architecture identifier, using the architecture vocabulary
-  defined by the EFI specification (i.e. `IA32`, `x64`, `IA64`, `ARM`, `AA64`,
-  …). If specified and it does not match the local system architecture this
-  entry should be hidden. The comparison should be done case-insensitively.
-
-  Example: `architecture aa64`
-
-Each boot loader menu entry drop-in snippet must include at least a `linux` or an `efi`
-key. Here is an example for a complete drop-in file:
-
-    # /boot/loader/entries/6a9857a393724b7a981ebb5b8495b9ea-3.8.0-2.fc19.x86_64.conf
-    title        Fedora 19 (Rawhide)
-    sort-key     fedora
-    machine-id   6a9857a393724b7a981ebb5b8495b9ea
-    version      3.8.0-2.fc19.x86_64
-    options      root=UUID=6d3376e4-fc93-4509-95ec-a21d68011da2 quiet
-    architecture x64
-    linux        /6a9857a393724b7a981ebb5b8495b9ea/3.8.0-2.fc19.x86_64/linux
-    initrd       /6a9857a393724b7a981ebb5b8495b9ea/3.8.0-2.fc19.x86_64/initrd
-
-On EFI systems all Linux kernel images should be EFI images. In order to
-increase compatibility with EFI systems it is highly recommended only to
-install EFI kernel images, even on non-EFI systems, if that's applicable and
-supported on the specific architecture.
-
-Conversely, in order to increase compatibility it is recommended to install
-generic kernel images that make few assumptions about the firmware they run on,
-i.e. it is a good idea that both images shipped as UEFI PE images and those
-which are not don't make unnecessary assumption on the underlying firmware,
-i.e. don't hard depend on legacy BIOS calls or UEFI boot services.
-
-When Type #1 boot loader menu entry snippets refer to other files (for `linux`,
-`initrd`, `efi`, `devicetree`, and `devicetree-overlay`), those files must be
-located on the same partition, and the paths must be absolute paths relative to
-the root of that file system. The naming of those files can be chosen by the
-installer. A recommended scheme is described in the next section. Paths should
-be normalized, i.e. not include `..`, `.` or a sequence of more than one
-`/`. Paths may be prefixed with a `/`, but this is optional and has the same
-effect as paths without it: all paths are always relative to the root directory
-of the partition they are referenced from.
-
-Even though the backing file system is typically case-insensitive (i.e. VFAT)
-it is strongly recommended to reference files in the casing actually used for
-the directories/files, so that placing these files on other file systems is
-still safe and robust.
-
-### Recommended Directory Layout for Additional Files
-
-It is recommended to place the kernel and other other files comprising a single
-boot loader entry in a separate directory:
-`/<entry-token-or-machine-id>/<version>/`. This naming scheme uses the same
-elements as the boot loader menu entry snippet, providing the same level of
-uniqueness.
-
-Example: `$BOOT/6a9857a393724b7a981ebb5b8495b9ea/3.8.0-2.fc19.x86_64/linux`
-         `$BOOT/6a9857a393724b7a981ebb5b8495b9ea/3.8.0-2.fc19.x86_64/initrd`
-
-Other naming schemes are possible. In particular, traditionally a flat naming
-scheme with files in the root directory was used. This is not recommended
-because it is hard to avoid conflicts in a multi-boot installation.
-
-### Standard-conformance Marker File
-
-Unfortunately, there are implementations of boot loading infrastructure that
-are also using the `/loader/entries/` directory, but install files that do not
-follow this specification. In order to minimize confusion, a boot loader
-implementation may place the file `/loader/entries.srel` next to the
-`/loader/entries/` directory containing the ASCII string `type1` (followed by a
-UNIX newline). Tools that need to determine whether an existing directory
-implements the semantics described here may check for this file and contents:
-if it exists and contains the mentioned string, it shall assume a
-standards-compliant implementation is in place. If it exists but contains a
-different string it shall assume other semantics are implemented. If the file
-does not exist, no assumptions should be made.
-
-### Type #2 EFI Unified Kernel Images
-
-A unified kernel image is a single EFI PE executable combining an EFI stub
-loader, a kernel image, an initrd image, and the kernel command line. See
-[systemd-stub(7)](https://www.freedesktop.org/software/systemd/man/systemd-stub.html)
-for details. The primary place for such unified images is the `/EFI/Linux/`
-directory in `$BOOT`. Operating systems should place unified EFI kernels only
-in the `$BOOT` partition. Boot loaders should also look in the `/EFI/Linux/` of
-the ESP — if it is different from `$BOOT` — and present a merged list of menu
-entries from both partitions. Regardless if placed in the primary or secondary
-location: the files must have the extension `.efi`.  Support for images of this
-type is of course specific to systems with EFI firmware. Ignore this section if
-you work on systems not supporting EFI.
-
-Type #2 file names should be chosen from the same restricted character set as
-Type #1 described above (but with the file name suffix of `.efi` instead of
-`.conf`).
-
-Images of this type have the advantage that all metadata and payload that makes
-up the boot entry is contained in a single PE file that can be signed
-cryptographically as one for the purpose of EFI SecureBoot.
-
-A valid unified kernel image in the `/EFI/Linux/` directory must contain two PE sections:
-
-* `.cmdline` section with the kernel command line,
-* `.osrel` section with an embedded copy of the
-  [os-release](https://www.freedesktop.org/software/systemd/man/os-release.html)
-  file describing the image.
-
-The `PRETTY_NAME=` and `VERSION_ID=` fields in the embedded `os-release` file
-are used the same as `title` and `version` in the Type #1 entries. The
-`.cmdline` section is used instead of the `options` field. `linux` and `initrd`
-fields are not necessary, and there is no counterpart for the `machine-id`
-field.
-
-On EFI, any such images shall be added to the list of valid boot entries.
-
-### Additional Notes
-
-Note that these boot entry snippets and unified kernels do not need to be the
-only menu entry sources for a boot loader. It may extend this list of
-entries with additional items from other configuration files (for example its
-own native configuration files) or automatically detected other entries without
-explicit configuration.
-
-To make this explicitly clear: this specification is designed with "free"
-operating systems in mind, starting Windows or MacOS is out of focus with these
-boot loader menu entry snippets, use boot-loader specific solutions for
-that. In the text above, if we say "OS" we hence imply "free", i.e. primarily
-Linux (though this could be easily be extended to the BSDs and whatnot).
-
-Note that all paths used in the boot loader menu entry snippets use a
-Unix-style "/" as path separator. This needs to be converted to an EFI-style
-"\\" separator in EFI boot loaders.
-
-
-## Locating Boot Entries
-
-A _boot loader_ locates the XBOOTLDR partition and the ESP, then simply reads
-all the files `/loader/entries/*.conf` in them, and populates its boot menu
-(and handle gracefully if one of the two partitions is missing). On EFI, it
-then extends this with any unified kernel images found in `/EFI/Linux/*.efi` in
-the two partitions. It may also add additional entries, for example a "Reboot
-into firmware" option.  Optionally it may sort the menu based on the
-`sort-key`, `machine-id` and `version` fields, and possibly others. It uses the
-file name to identify specific items, for example in case it supports storing
-away default entry information somewhere. A boot loader should generally not
-modify these files.
-
-For "Boot Loader Specification Entries" (Type #1), the _kernel package
-installer_ installs the kernel and initrd images to `$BOOT`. It is recommended
-to place these files in a vendor and OS and installation specific directory. It
-then generates a boot loader menu entry snippet, placing it in
-`$BOOT/loader/entries/xyz.conf`, with "xyz" as concatenation of
-entry-token/machine-id and version information (see above). The files created
-by a kernel package are tied to the kernel package and should be removed along
-with it.
-
-For "EFI Unified Kernel Images" (Type #2), the vendor or kernel package
-installer should create the combined image and drop it into
-`$BOOT/EFI/Linux/`. This file is also tied to the kernel package and should be
-removed along with it.
-
-A _UI application_ intended to show available boot options shall operate
-similarly to a boot loader (and thus search both `$BOOT` and the ESP if
-distinct), but might apply additional filters, for example by filtering the
-booted OS via the machine ID, or by suppressing all but the newest kernel
-versions.
-
-An _OS installer_ picks the right place for `$BOOT` as defined above (possibly
-creating a partition and file system for it) and creates the `/loader/entries/`
-directory and the `/loader/entries.srel` file in it (the latter only if the
-directory didn't exist yet). It then installs an appropriate boot loader that
-can read these snippets. Finally, it installs one or more kernel packages.
-
-## Boot counting
-
-The main idea is that when boot entries are initially installed, they are
-marked as "indeterminate" and assigned a number of boot attempts. Each time the
-boot loader tries to boot an entry, it decreases this count by one. If the
-operating system considers the boot as successful, it removes the counter
-altogether and the entry becomes "good". Otherwise, once the assigned number of
-boots is exhausted, the entry is marked as "bad".
-
-Which boots are "successful" is determined by the operating system. systemd
-provides a generic mechanism that can be extended with arbitrary checks and
-actions, see [Automatic Boot Assessment](AUTOMATIC_BOOT_ASSESSMENT.md), but the
-boot counting mechanism described in this specification can also be used with
-other implementations.
-
-The boot counting data is stored in the name of the boot loader entry. A boot
-loader entry file name may contain a plus (`+`) followed by a number. This may
-optionally be followed by a minus (`-`) followed by a second number. The dot
-(`.`) and file name suffix (`conf` of `efi`) must immediately follow. Boot
-counting is enabled for entries which match this pattern.
-
-The first number is the "tries left" counter signifying how many attempts to boot
-this entry shall still be made. The second number is the "tries done" counter,
-showing how many failed attempts to boot it have already been made. Each time
-a boot loader entry marked this way is booted, the first counter is decremented,
-and the second one incremented. (If the second counter is missing,
-then it is assumed to be equivalent to zero.) If the "tries left" counter is
-above zero the entry is still considered "indeterminate". A boot entry with the
-"tries left" counter at zero is considered "bad".
-
-If the boot attempt completed successfully the entry's counters are removed
-from the name (entry state becomes "good"), thus turning off boot counting for
-this entry.
-
-## Sorting
-
-The boot loader menu should generally show entries in some order meaningful to
-the user. The `title` key is free-form and not suitable to be used as the
-primary sorting key. Instead, the boot loader should use the following rules:
-
-1. Entries which are subject to boot counting and are marked as "bad", should
-   be sorted later than all other entries. Entries which are marked as
-   "indeterminate" or "good" (or were not subject to boot counting at all),
-   are thus sorted earlier.
-
-2. If `sort-key` is set on both entries, use in order of priority,
-   the `sort-key` (A-Z, increasing [alphanumerical order](#alphanumerical-order)),
-   `machine-id` (A-Z, increasing alphanumerical order),
-   and `version` keys (decreasing [version order](#version-order)).
-
-3. If `sort-key` is set on one entry, it sorts earlier.
-
-4. At the end, if necessary, when `sort-key` is not set or those fields are not
-   set or are all equal, the boot loader should sort using the file name of the
-   entry (decreasing version sort), with the suffix removed.
-
-**Note:** _This description assumes that the boot loader shows entries in a
-traditional menu, with newest and "best" entries at the top, thus entries with
-a higher version number are sorter *earlier*. The boot loader is free to
-use a different direction (or none at all) during display._
-
-**Note:** _The boot loader should allow booting "bad" entries, e.g. in case no
-other entries are left or they are unusable for other reasons. It may
-deemphasize or hide such entries by default._
-
-**Note:** _"Bad" boot entries have a suffix of "+0-`n`", where `n` is the
-number of failed boot attempts. Removal of the suffix is not necessary for
-comparisons described by the last point above. In the unlikely scenario that we
-have multiple such boot entries that differ only by the boot counting data, we
-would sort them by `n`._
-
-### Alphanumerical Order
-
-Free-form strings and machine IDs should be compared using a method equivalent
-to [strcmp(3)](https://man7.org/linux/man-pages/man3/strcmp.3.html) on their
-UTF-8 representations. If just one of the strings is unspecified or empty, it
-compares lower. If both strings are unspecified or empty, they compare equal.
-
-### Version Order
-
-The following method should be used to compare version strings. The algorithm
-is based on rpm's `rpmvercmp()`, but not identical.
-
-ASCII letters (`a-z`, `A-Z`) and digits (`0-9`) form alphanumerical components of the version.
-Minus (`-`) separates the version and release parts.
-Dot (`.`) separates parts of version or release.
-Tilde (`~`) is a prefix that always compares lower.
-Caret (`^`) is a prefix that always compares higher.
-
-Both strings are compared from the beginning until the end, or until the
-strings are found to compare as different. In a loop:
-1. Any characters which are outside of the set of listed above (`a-z`, `A-Z`, `0-9`, `-`, `.`, `~`, `^`)
-   are skipped in both strings. In particular, this means that non-ASCII characters
-   that are Unicode digits or letters are skipped too.
-2. If one of the strings has ended: if the other string hasn't, the string that
-   has remaining characters compares higher. Otherwise, the strings compare
-   equal.
-3. If the remaining part of one of strings starts with `~`:
-   if other remaining part does not start with `~`,
-   the string with `~` compares lower. Otherwise, both tilde characters are skipped.
-4. The check from point 2. is repeated here.
-5. If the remaining part of one of strings starts with `-`:
-   if the other remaining part does not start with `-`,
-   the string with `-` compares lower. Otherwise, both minus characters are skipped.
-6. If the remaining part of one of strings starts with `^`:
-   if the other remaining part does not start with `^`,
-   the string with `^` compares higher. Otherwise, both caret characters are skipped.
-6. If the remaining part of one of strings starts with `.`:
-   if the other remaining part does not start with `.`,
-   the string with `.` compares lower. Otherwise, both dot characters are skipped.
-7. If either of the remaining parts starts with a digit, numerical prefixes are
-   compared numerically. Any leading zeroes are skipped.
-   The numerical prefixes (until the first non-digit character) are evaluated as numbers.
-   If one of the prefixes is empty, it evaluates as 0.
-   If the numbers are different, the string with the bigger number compares higher.
-   Otherwise, the comparison continues at the following characters at point 1.
-8. Leading alphabetical prefixes are compared alphabetically.
-   The substrings are compared letter-by-letter.
-   If both letters are the same, the comparison continues with the next letter.
-   Capital letters compare lower than lower-case letters (`A < a`).
-   When the end of one substring has been reached (a non-letter character or the end
-   of the whole string), if the other substring has remaining letters, it compares higher.
-   Otherwise, the comparison continues at the following characters at point 1.
-
-Examples (with '' meaning the empty string):
-
-* `11 == 11`
-* `systemd-123 == systemd-123`
-* `bar-123 < foo-123`
-* `123a > 123`
-* `123.a > 123`
-* `123.a < 123.b`
-* `123a > 123.a`
-* `11α == 11β`
-* `A < a`
-* '' < `0`
-* `0.` > `0`
-* `0.0` > `0`
-* `0` < `~`
-* '' < `~`
-
-Note: [systemd-analyze](https://www.freedesktop.org/software/systemd/man/systemd-analyze.html)
-implements this version comparison algorithm as
-```
-systemd-analyze compare-versions <version-a> <version-b>
-```
-
-## Additional discussion
-
-### Why is there a need for this specification?
-
-This specification brings the following advantages:
-
-* Installation of new boot entries is more robust, as no explicit rewriting of
-  configuration files is required.
-
-* It allows an out-of-the-box boot experience on any platform without the need
-  of traditional firmware mechanisms (e.g. BIOS calls, UEFI Boot Services).
-
-* It improves dual-boot scenarios. Without cooperation, multiple Linux
-  installations tend to fight over which boot loader becomes the primary one in
-  possession of the MBR or the boot partition, and only that one installation
-  can then update the boot loader configuration. Other Linux installs have to
-  be manually configured to never touch the MBR and instead install a
-  chain-loaded boot loader in their own partition headers. In this new scheme
-  all installations share a loader directory and no manual configuration has to
-  take place. All participants implicitly cooperate due to removal of name
-  collisions and can install/remove their own boot menu entries without
-  interfering with the entries of other installed operating systems.
-
-* Drop-in directories are now pretty ubiquitous on Linux as an easy way to
-  extend boot loader menus without having to edit, regenerate or manipulate
-  configuration files. For the sake of uniformity, we should do the same for
-  the boot menu.
-
-* Userspace code can sanely parse boot loader menu entries which is essential
-  with modern firmware which does not necessarily initialize USB keyboards
-  during boot, which makes boot menus hard to reach for the user. If userspace
-  code can parse the boot loader menu entries too, UI can be written that
-  select a boot menu item to boot into before rebooting the machine, thus not
-  requiring interactivity during early boot.
-
-* To unify and thus simplify menu entries of the various boot loaders, which
-  makes configuration of the boot loading process easier for users,
-  administrators, and developers alike.
-
-* For boot loaders with configuration _scripts_ such as grub2, adopting this
-  spec allows for mostly static scripts that are generated only once at first
-  installation, but then do not need to be updated anymore as that is done via
-  drop-in files exclusively.
-
-### Why not simply rely on the EFI boot menu logic?
-
-EFI is not ubiquitous, especially not in embedded systems. But even on systems
-with EFI, which provides a boot options logic that can offer similar
-functionality, this specification is still needed for the following reasons:
-
-* The various EFI implementations implement the boot order/boot item logic to
-  different levels. Some firmware implementations do not offer a boot menu at
-  all and instead unconditionally follow the EFI boot order, booting the first
-  item that is working.
-
-* If the firmware setup is used to reset data, usually all EFI boot entries
-  are lost, making the system entirely unbootable, as the firmware setups
-  generally do not offer a UI to define additional boot items. By placing the
-  menu item information on disk, it is always available, even if the firmware
-  configuration is lost.
-
-* Harddisk images should be movable between machines and be bootable without
-  requiring firmware configuration. This also requires that the list
-  of boot options is defined on disk, and not in EFI variables alone.
-
-* EFI is not universal yet (especially on non-x86 platforms), this
-  specification is useful both for EFI and non-EFI boot loaders.
-
-* Many EFI systems disable USB support during early boot to optimize boot
-  times, thus making keyboard input unavailable in the EFI menu. It is thus
-  useful if the OS UI has a standardized way to discover available boot options
-  which can be booted to.
-
-### Why is the version comparison logic so complicated?
-
-The `sort-key` allows us to group entries by "operating system", e.g. all
-versions of Fedora together, no matter if they identify themselves as "Fedora
-Workstation" or "Fedora Rawhide (prerelease)". The `sort-key` was introduced
-only recently, so we need to provide a meaningful order for entries both with
-and without it. Since it is a new concept, it is assumed that entries with
-`sort-key` are newer.
-
-In a traditional menu with entries displayed vertically, we want names to be
-sorter alpabetically (CentOS, Debian, Fedora, OpenSUSE, …), it would be strange
-to have them in reverse order. But when multiple kernels are available for the
-same installation, we want to display the latest kernel with highest priority,
-i.e. earlier in the list.
-
-### Why do you use file renames to store the counter? Why not a regular file?
-
-Mainly two reasons: it's relatively likely that renames can be implemented
-atomically even in simpler file systems, as renaming generally avoids
-allocating or releasing data blocks. Writing to file contents has a much bigger
-chance to be result in incomplete or corrupt data. Moreover renaming has the
-benefit that the boot count metadata is directly attached to the boot loader
-entry file, and thus the lifecycle of the metadata and the entry itself are
-bound together. This means no additional clean-up needs to take place to drop
-the boot loader counting information for an entry when it is removed.
-
-### Why not use EFI variables for storing the boot counter?
-
-The memory chips used to back the persistent EFI variables are generally not of
-the highest quality, hence shouldn't be written to more than necessary. This
-means we can't really use it for changes made regularly during boot, but should
-use it only for seldom-made configuration changes.
-
-### Out of Focus
-
-There are a couple of items that are out of focus for this specification:
-
-* If userspace can figure out the available boot options, then this is only
-  useful so much: we'd still need to come up with a way how userspace could
-  communicate to the boot loader the default boot loader entry temporarily or
-  persistently. Defining a common scheme for this is certainly a good idea, but
-  out of focus for this specification.
-
-* This specification is just about "Free" Operating systems. Hooking in other
-  operating systems (like Windows and macOS) into the boot menu is a different
-  story and should probably happen outside of this specification. For example,
-  boot loaders might choose to detect other available OSes dynamically at
-  runtime without explicit configuration (like `systemd-boot` does it), or via
-  native configuration (for example via explicit Grub2 configuration generated
-  once at installation).
-
-* This specification leaves undefined what to do about systems which are
-  upgraded from an OS that does not implement this specification. As the
-  previous boot loader logic was largely handled by in distribution-specific
-  ways we probably should leave the upgrade path (and whether there actually is
-  one) to the distributions. The simplest solution might be to simply continue
-  with the old scheme for old installations and use this new scheme only for
-  new installations.
-
-* Referencing kernels or initrds on other partitions other than the partition
-  containing the Type #1 boot loader entry. This is by design, as specifying
-  other partitions or devices would require a non-trivial language for denoting
-  device paths. In particular this means that on non-EFI systems boot loader
-  menu entry snippets following this specification cannot be used to spawn
-  other operating systems (such as Windows).
-
-
-## Links
-
-[GUID Partition Table](https://en.wikipedia.org/wiki/GUID_Partition_Table)<br>
-[Boot Loader Interface](BOOT_LOADER_INTERFACE.md)<br>
-[Discoverable Partitions Specification](DISCOVERABLE_PARTITIONS.md)<br>
-[`systemd-boot(7)`](https://www.freedesktop.org/software/systemd/man/systemd-boot.html)<br>
-[`bootctl(1)`](https://www.freedesktop.org/software/systemd/man/bootctl.html)<br>
-[`systemd-gpt-auto-generator(8)`](https://www.freedesktop.org/software/systemd/man/systemd-gpt-auto-generator.html)
+[This content has moved to the UAPI group website](https://uapi-group.org/specifications/specs/boot_loader_specification/)
diff --git a/docs/DISCOVERABLE_PARTITIONS.md b/docs/DISCOVERABLE_PARTITIONS.md
index efd20533a5..bc05b6cc5a 100644
--- a/docs/DISCOVERABLE_PARTITIONS.md
+++ b/docs/DISCOVERABLE_PARTITIONS.md
@@ -1,423 +1 @@
----
-title: Discoverable Partitions Specification
-category: Concepts
-layout: default
-SPDX-License-Identifier: LGPL-2.1-or-later
----
-# The Discoverable Partitions Specification (DPS)
-
-_TL;DR: Let's automatically discover, mount and enable the root partition,
-`/home/`, `/srv/`, `/var/` and `/var/tmp/` and the swap partitions based on
-GUID Partition Tables (GPT)!_
-
-This specification describes the use of GUID Partition Table (GPT) UUIDs to
-enable automatic discovery of partitions and their intended mountpoints.
-Traditionally Linux has made little use of partition types, mostly just
-defining one UUID for file system/data partitions and another one for swap
-partitions. With this specification, we introduce additional partition types
-for specific uses. This has many benefits:
-
-* OS installers can automatically discover and make sense of partitions of
-  existing Linux installations.
-* The OS can discover and mount the necessary file systems with a non-existent
-  or incomplete `/etc/fstab` file and without the `root=` kernel command line
-  option.
-* Container managers (such as nspawn and libvirt-lxc) can introspect and set up
-  file systems contained in GPT disk images automatically and mount them to the
-  right places, thus allowing booting the same, identical images on bare metal
-  and in Linux containers. This enables true, natural portability of disk
-  images between physical machines and Linux containers.
-* As a help to administrators and users partition manager tools can show more
-  descriptive information about partitions tables.
-
-Note that the OS side of this specification is currently implemented in
-[systemd](https://systemd.io/) 211 and newer in the
-[systemd-gpt-auto-generator(8)](https://www.freedesktop.org/software/systemd/man/systemd-gpt-auto-generator.html)
-generator tool. Note that automatic discovery of the root only works if the
-boot loader communicates this information to the OS, by implementing the
-[Boot Loader Interface](BOOT_LOADER_INTERFACE.md).
-
-## Defined Partition Type UUIDs
-
-| Name | Partition Type UUID | Allowed File Systems | Explanation |
-|------|---------------------|----------------------|-------------|
-| _Root Partition (Alpha)_ | `6523f8ae-3eb1-4e2a-a05a-18b695ae656f` `SD_GPT_ROOT_ALPHA` | Any native, optionally in LUKS | On systems with matching architecture, the first partition with this type UUID on the disk containing the active EFI ESP is automatically mounted to the root directory `/`. If the partition is encrypted with LUKS or has dm-verity integrity data (see below), the device mapper file will be named `/dev/mapper/root`. |
-| _Root Partition (ARC)_ | `d27f46ed-2919-4cb8-bd25-9531f3c16534` `SD_GPT_ROOT_ARC` | ditto | ditto |
-| _Root Partition (32-bit ARM)_ | `69dad710-2ce4-4e3c-b16c-21a1d49abed3` `SD_GPT_ROOT_ARM` | ditto | ditto |
-| _Root Partition (64-bit ARM/AArch64)_ | `b921b045-1df0-41c3-af44-4c6f280d3fae` `SD_GPT_ROOT_ARM64` | ditto | ditto |
-| _Root Partition (Itanium/IA-64)_ | `993d8d3d-f80e-4225-855a-9daf8ed7ea97` `SD_GPT_ROOT_IA64` | ditto | ditto |
-| _Root Partition (LoongArch 64-bit)_ | `77055800-792c-4f94-b39a-98c91b762bb6` `SD_GPT_ROOT_LOONGARCH64` | ditto | ditto |
-| _Root Partition (32-bit MIPS LittleEndian (mipsel))_ | `37c58c8a-d913-4156-a25f-48b1b64e07f0` `SD_GPT_ROOT_MIPS_LE` | ditto | ditto |
-| _Root Partition (64-bit MIPS LittleEndian (mips64el))_ | `700bda43-7a34-4507-b179-eeb93d7a7ca3` `SD_GPT_ROOT_MIPS64_LE` | ditto | ditto |
-| _Root Partition (HPPA/PARISC)_ | `1aacdb3b-5444-4138-bd9e-e5c2239b2346` `SD_GPT_ROOT_PARISC` | ditto | ditto |
-| _Root Partition (32-bit PowerPC)_ | `1de3f1ef-fa98-47b5-8dcd-4a860a654d78` `SD_GPT_ROOT_PPC` | ditto | ditto |
-| _Root Partition (64-bit PowerPC BigEndian)_ | `912ade1d-a839-4913-8964-a10eee08fbd2` `SD_GPT_ROOT_PPC64` | ditto | ditto |
-| _Root Partition (64-bit PowerPC LittleEndian)_ | `c31c45e6-3f39-412e-80fb-4809c4980599` `SD_GPT_ROOT_PPC64_LE` | ditto | ditto |
-| _Root Partition (RISC-V 32-bit)_ | `60d5a7fe-8e7d-435c-b714-3dd8162144e1` `SD_GPT_ROOT_RISCV32` | ditto | ditto |
-| _Root Partition (RISC-V 64-bit)_ | `72ec70a6-cf74-40e6-bd49-4bda08e8f224` `SD_GPT_ROOT_RISCV64` | ditto | ditto |
-| _Root Partition (s390)_ | `08a7acea-624c-4a20-91e8-6e0fa67d23f9` `SD_GPT_ROOT_S390` | ditto | ditto |
-| _Root Partition (s390x)_ | `5eead9a9-fe09-4a1e-a1d7-520d00531306` `SD_GPT_ROOT_S390X` | ditto | ditto |
-| _Root Partition (TILE-Gx)_ | `c50cdd70-3862-4cc3-90e1-809a8c93ee2c` `SD_GPT_ROOT_TILEGX` | ditto | ditto |
-| _Root Partition (x86)_ | `44479540-f297-41b2-9af7-d131d5f0458a` `SD_GPT_ROOT_X86` | ditto | ditto |
-| _Root Partition (amd64/x86_64)_ | `4f68bce3-e8cd-4db1-96e7-fbcaf984b709` `SD_GPT_ROOT_X86_64` | ditto | ditto |
-| _`/usr/` Partition (Alpha)_ | `e18cf08c-33ec-4c0d-8246-c6c6fb3da024` `SD_GPT_USR_ALPHA` | Any native, optionally in LUKS | Similar semantics to root partition, but just the `/usr/` partition. |
-| _`/usr/` Partition (ARC)_ | `7978a683-6316-4922-bbee-38bff5a2fecc` `SD_GPT_USR_ARC` | ditto | ditto |
-| _`/usr/` Partition (32-bit ARM)_ | `7d0359a3-02b3-4f0a-865c-654403e70625` `SD_GPT_USR_ARM` | ditto | ditto |
-| _`/usr/` Partition (64-bit ARM/AArch64)_ | `b0e01050-ee5f-4390-949a-9101b17104e9` `SD_GPT_USR_ARM64` | ditto | ditto |
-| _`/usr/` Partition (Itanium/IA-64)_ | `4301d2a6-4e3b-4b2a-bb94-9e0b2c4225ea` `SD_GPT_USR_IA64` | ditto | ditto |
-| _`/usr/` Partition (LoongArch 64-bit)_ | `e611c702-575c-4cbe-9a46-434fa0bf7e3f` `SD_GPT_USR_LOONGARCH64` | ditto | ditto |
-| _`/usr/` Partition (32-bit MIPS LittleEndian (mipsel))_ | `0f4868e9-9952-4706-979f-3ed3a473e947` `SD_GPT_USR_MIPS_LE` | ditto | ditto |
-| _`/usr/` Partition (64-bit MIPS LittleEndian (mips64el))_ | `c97c1f32-ba06-40b4-9f22-236061b08aa8` `SD_GPT_USR_MIPS64_LE` | ditto | ditto |
-| _`/usr/` Partition (HPPA/PARISC)_ | `dc4a4480-6917-4262-a4ec-db9384949f25` `SD_GPT_USR_PARISC` | ditto | ditto |
-| _`/usr/` Partition (32-bit PowerPC)_ | `7d14fec5-cc71-415d-9d6c-06bf0b3c3eaf` `SD_GPT_USR_PPC` | ditto | ditto |
-| _`/usr/` Partition (64-bit PowerPC BigEndian)_ | `2c9739e2-f068-46b3-9fd0-01c5a9afbcca` `SD_GPT_USR_PPC64` | ditto | ditto |
-| _`/usr/` Partition (64-bit PowerPC LittleEndian)_ | `15bb03af-77e7-4d4a-b12b-c0d084f7491c` `SD_GPT_USR_PPC64_LE` | ditto | ditto |
-| _`/usr/` Partition (RISC-V 32-bit)_ | `b933fb22-5c3f-4f91-af90-e2bb0fa50702` `SD_GPT_USR_RISCV32` | ditto | ditto |
-| _`/usr/` Partition (RISC-V 64-bit)_ | `beaec34b-8442-439b-a40b-984381ed097d` `SD_GPT_USR_RISCV64` | ditto | ditto |
-| _`/usr/` Partition (s390)_ | `cd0f869b-d0fb-4ca0-b141-9ea87cc78d66` `SD_GPT_USR_S390` | ditto | ditto |
-| _`/usr/` Partition (s390x)_ | `8a4f5770-50aa-4ed3-874a-99b710db6fea` `SD_GPT_USR_S390X` | ditto | ditto |
-| _`/usr/` Partition (TILE-Gx)_ | `55497029-c7c1-44cc-aa39-815ed1558630` `SD_GPT_USR_TILEGX` | ditto | ditto |
-| _`/usr/` Partition (x86)_ | `75250d76-8cc6-458e-bd66-bd47cc81a812` `SD_GPT_USR_X86` | ditto | ditto |
-| _`/usr/` Partition (amd64/x86_64)_ | `8484680c-9521-48c6-9c11-b0720656f69e` `SD_GPT_USR_X86_64` | ditto | ditto |
-| _Root Verity Partition (Alpha)_ | `fc56d9e9-e6e5-4c06-be32-e74407ce09a5` `SD_GPT_ROOT_ALPHA_VERITY` | A dm-verity superblock followed by hash data | Contains dm-verity integrity hash data for the matching root partition. If this feature is used the partition UUID of the root partition should be the first 128 bits of the root hash of the dm-verity hash data, and the partition UUID of this dm-verity partition should be the final 128 bits of it, so that the root partition and its Verity partition can be discovered easily, simply by specifying the root hash. |
-| _Root Verity Partition (ARC)_ | `24b2d975-0f97-4521-afa1-cd531e421b8d` `SD_GPT_ROOT_ARC_VERITY` | ditto | ditto |
-| _Root Verity Partition (32-bit ARM)_ | `7386cdf2-203c-47a9-a498-f2ecce45a2d6` `SD_GPT_ROOT_ARM_VERITY` | ditto | ditto |
-| _Root Verity Partition (64-bit ARM/AArch64)_ | `df3300ce-d69f-4c92-978c-9bfb0f38d820` `SD_GPT_ROOT_ARM64_VERITY` | ditto | ditto |
-| _Root Verity Partition (Itanium/IA-64)_ | `86ed10d5-b607-45bb-8957-d350f23d0571` `SD_GPT_ROOT_IA64_VERITY` | ditto | ditto |
-| _Root Verity Partition (LoongArch 64-bit)_ | `f3393b22-e9af-4613-a948-9d3bfbd0c535` `SD_GPT_ROOT_LOONGARCH64_VERITY` | ditto | ditto |
-| _Root Verity Partition (32-bit MIPS LittleEndian (mipsel))_ | `d7d150d2-2a04-4a33-8f12-16651205ff7b` `SD_GPT_ROOT_MIPS_LE_VERITY` | ditto | ditto |
-| _Root Verity Partition (64-bit MIPS LittleEndian (mips64el))_ | `16b417f8-3e06-4f57-8dd2-9b5232f41aa6` `SD_GPT_ROOT_MIPS64_LE_VERITY` | ditto | ditto |
-| _Root Verity Partition (HPPA/PARISC)_ | `d212a430-fbc5-49f9-a983-a7feef2b8d0e` `SD_GPT_ROOT_PARISC_VERITY` | ditto | ditto |
-| _Root Verity Partition (64-bit PowerPC LittleEndian)_ | `906bd944-4589-4aae-a4e4-dd983917446a` `SD_GPT_ROOT_PPC64_LE_VERITY` | ditto | ditto |
-| _Root Verity Partition (64-bit PowerPC BigEndian)_ | `9225a9a3-3c19-4d89-b4f6-eeff88f17631` `SD_GPT_ROOT_PPC64_VERITY` | ditto | ditto |
-| _Root Verity Partition (32-bit PowerPC)_ | `98cfe649-1588-46dc-b2f0-add147424925` `SD_GPT_ROOT_PPC_VERITY` | ditto | ditto |
-| _Root Verity Partition (RISC-V 32-bit)_ | `ae0253be-1167-4007-ac68-43926c14c5de` `SD_GPT_ROOT_RISCV32_VERITY` | ditto | ditto |
-| _Root Verity Partition (RISC-V 64-bit)_ | `b6ed5582-440b-4209-b8da-5ff7c419ea3d` `SD_GPT_ROOT_RISCV64_VERITY` | ditto | ditto |
-| _Root Verity Partition (s390)_ | `7ac63b47-b25c-463b-8df8-b4a94e6c90e1` `SD_GPT_ROOT_S390_VERITY` | ditto | ditto |
-| _Root Verity Partition (s390x)_ | `b325bfbe-c7be-4ab8-8357-139e652d2f6b` `SD_GPT_ROOT_S390X_VERITY` | ditto | ditto |
-| _Root Verity Partition (TILE-Gx)_ | `966061ec-28e4-4b2e-b4a5-1f0a825a1d84` `SD_GPT_ROOT_TILEGX_VERITY` | ditto | ditto |
-| _Root Verity Partition (amd64/x86_64)_ | `2c7357ed-ebd2-46d9-aec1-23d437ec2bf5` `SD_GPT_ROOT_X86_64_VERITY` | ditto | ditto |
-| _Root Verity Partition (x86)_ | `d13c5d3b-b5d1-422a-b29f-9454fdc89d76` `SD_GPT_ROOT_X86_VERITY` | ditto | ditto |
-| _`/usr/` Verity Partition (Alpha)_ | `8cce0d25-c0d0-4a44-bd87-46331bf1df67` `SD_GPT_USR_ALPHA_VERITY` | A dm-verity superblock followed by hash data | Similar semantics to root Verity partition, but just for the `/usr/` partition. |
-| _`/usr/` Verity Partition (ARC)_ | `fca0598c-d880-4591-8c16-4eda05c7347c` `SD_GPT_USR_ARC_VERITY` | ditto | ditto |
-| _`/usr/` Verity Partition (32-bit ARM)_ | `c215d751-7bcd-4649-be90-6627490a4c05` `SD_GPT_USR_ARM_VERITY` | ditto | ditto |
-| _`/usr/` Verity Partition (64-bit ARM/AArch64)_ | `6e11a4e7-fbca-4ded-b9e9-e1a512bb664e` `SD_GPT_USR_ARM64_VERITY` | ditto | ditto |
-| _`/usr/` Verity Partition (Itanium/IA-64)_ | `6a491e03-3be7-4545-8e38-83320e0ea880` `SD_GPT_USR_IA64_VERITY` | ditto | ditto |
-| _`/usr/` Verity Partition (LoongArch 64-bit)_ | `f46b2c26-59ae-48f0-9106-c50ed47f673d` `SD_GPT_USR_LOONGARCH64_VERITY` | ditto | ditto |
-| _`/usr/` Verity Partition (32-bit MIPS LittleEndian (mipsel))_ | `46b98d8d-b55c-4e8f-aab3-37fca7f80752` `SD_GPT_USR_MIPS_LE_VERITY` | ditto | ditto |
-| _`/usr/` Verity Partition (64-bit MIPS LittleEndian (mips64el))_ | `3c3d61fe-b5f3-414d-bb71-8739a694a4ef` `SD_GPT_USR_MIPS64_LE_VERITY` | ditto | ditto |
-| _`/usr/` Verity Partition (HPPA/PARISC)_ | `5843d618-ec37-48d7-9f12-cea8e08768b2` `SD_GPT_USR_PARISC_VERITY` | ditto | ditto |
-| _`/usr/` Verity Partition (64-bit PowerPC LittleEndian)_ | `ee2b9983-21e8-4153-86d9-b6901a54d1ce` `SD_GPT_USR_PPC64_LE_VERITY` | ditto | ditto |
-| _`/usr/` Verity Partition (64-bit PowerPC BigEndian)_ | `bdb528a5-a259-475f-a87d-da53fa736a07` `SD_GPT_USR_PPC64_VERITY` | ditto | ditto |
-| _`/usr/` Verity Partition (32-bit PowerPC)_ | `df765d00-270e-49e5-bc75-f47bb2118b09` `SD_GPT_USR_PPC_VERITY` | ditto | ditto |
-| _`/usr/` Verity Partition (RISC-V 32-bit)_ | `cb1ee4e3-8cd0-4136-a0a4-aa61a32e8730` `SD_GPT_USR_RISCV32_VERITY` | ditto | ditto |
-| _`/usr/` Verity Partition (RISC-V 64-bit)_ | `8f1056be-9b05-47c4-81d6-be53128e5b54` `SD_GPT_USR_RISCV64_VERITY` | ditto | ditto |
-| _`/usr/` Verity Partition (s390)_ | `b663c618-e7bc-4d6d-90aa-11b756bb1797` `SD_GPT_USR_S390_VERITY` | ditto | ditto |
-| _`/usr/` Verity Partition (s390x)_ | `31741cc4-1a2a-4111-a581-e00b447d2d06` `SD_GPT_USR_S390X_VERITY` | ditto | ditto |
-| _`/usr/` Verity Partition (TILE-Gx)_ | `2fb4bf56-07fa-42da-8132-6b139f2026ae` `SD_GPT_USR_TILEGX_VERITY` | ditto | ditto |
-| _`/usr/` Verity Partition (amd64/x86_64)_ | `77ff5f63-e7b6-4633-acf4-1565b864c0e6` `SD_GPT_USR_X86_64_VERITY` | ditto | ditto |
-| _`/usr/` Verity Partition (x86)_ | `8f461b0d-14ee-4e81-9aa9-049b6fb97abd` `SD_GPT_USR_X86_VERITY` | ditto | ditto |
-| _Root Verity Signature Partition (Alpha)_ | `d46495b7-a053-414f-80f7-700c99921ef8` `SD_GPT_ROOT_ALPHA_VERITY_SIG` | A serialized JSON object, see below | Contains a root hash and a PKCS#7 signature for it, permitting signed dm-verity GPT images. |
-| _Root Verity Signature Partition (ARC)_ | `143a70ba-cbd3-4f06-919f-6c05683a78bc` `SD_GPT_ROOT_ARC_VERITY_SIG` | ditto | ditto |
-| _Root Verity Signature Partition (32-bit ARM)_ | `42b0455f-eb11-491d-98d3-56145ba9d037` `SD_GPT_ROOT_ARM_VERITY_SIG` | ditto | ditto |
-| _Root Verity Signature Partition (64-bit ARM/AArch64)_ | `6db69de6-29f4-4758-a7a5-962190f00ce3` `SD_GPT_ROOT_ARM64_VERITY_SIG` | ditto | ditto |
-| _Root Verity Signature Partition (Itanium/IA-64)_ | `e98b36ee-32ba-4882-9b12-0ce14655f46a` `SD_GPT_ROOT_IA64_VERITY_SIG` | ditto | ditto |
-| _Root Verity Signature Partition (LoongArch 64-bit)_ | `5afb67eb-ecc8-4f85-ae8e-ac1e7c50e7d0` `SD_GPT_ROOT_LOONGARCH64_VERITY_SIG` | ditto | ditto |
-| _Root Verity Signature Partition (32-bit MIPS LittleEndian (mipsel))_ | `c919cc1f-4456-4eff-918c-f75e94525ca5` `SD_GPT_ROOT_MIPS_LE_VERITY_SIG` | ditto | ditto |
-| _Root Verity Signature Partition (64-bit MIPS LittleEndian (mips64el))_ | `904e58ef-5c65-4a31-9c57-6af5fc7c5de7` `SD_GPT_ROOT_MIPS64_LE_VERITY_SIG` | ditto | ditto |
-| _Root Verity Signature Partition (HPPA/PARISC)_ | `15de6170-65d3-431c-916e-b0dcd8393f25` `SD_GPT_ROOT_PARISC_VERITY_SIG` | ditto | ditto |
-| _Root Verity Signature Partition (64-bit PowerPC LittleEndian)_ | `d4a236e7-e873-4c07-bf1d-bf6cf7f1c3c6` `SD_GPT_ROOT_PPC64_LE_VERITY_SIG` | ditto | ditto |
-| _Root Verity Signature Partition (64-bit PowerPC BigEndian)_ | `f5e2c20c-45b2-4ffa-bce9-2a60737e1aaf` `SD_GPT_ROOT_PPC64_VERITY_SIG` | ditto | ditto |
-| _Root Verity Signature Partition (32-bit PowerPC)_ | `1b31b5aa-add9-463a-b2ed-bd467fc857e7` `SD_GPT_ROOT_PPC_VERITY_SIG` | ditto | ditto |
-| _Root Verity Signature Partition (RISC-V 32-bit)_ | `3a112a75-8729-4380-b4cf-764d79934448` `SD_GPT_ROOT_RISCV32_VERITY_SIG` | ditto | ditto |
-| _Root Verity Signature Partition (RISC-V 64-bit)_ | `efe0f087-ea8d-4469-821a-4c2a96a8386a` `SD_GPT_ROOT_RISCV64_VERITY_SIG` | ditto | ditto |
-| _Root Verity Signature Partition (s390)_ | `3482388e-4254-435a-a241-766a065f9960` `SD_GPT_ROOT_S390_VERITY_SIG` | ditto | ditto |
-| _Root Verity Signature Partition (s390x)_ | `c80187a5-73a3-491a-901a-017c3fa953e9` `SD_GPT_ROOT_S390X_VERITY_SIG` | ditto | ditto |
-| _Root Verity Signature Partition (TILE-Gx)_ | `b3671439-97b0-4a53-90f7-2d5a8f3ad47b` `SD_GPT_ROOT_TILEGX_VERITY_SIG` | ditto | ditto |
-| _Root Verity Signature Partition (amd64/x86_64)_ | `41092b05-9fc8-4523-994f-2def0408b176` `SD_GPT_ROOT_X86_64_VERITY_SIG` | ditto | ditto |
-| _Root Verity Signature Partition (x86)_ | `5996fc05-109c-48de-808b-23fa0830b676` `SD_GPT_ROOT_X86_VERITY_SIG` | ditto | ditto |
-| _`/usr/` Verity Signature Partition (Alpha)_ | `5c6e1c76-076a-457a-a0fe-f3b4cd21ce6e` `SD_GPT_USR_ALPHA_VERITY_SIG` | A serialized JSON object, see below | Similar semantics to root Verity signature partition, but just for the `/usr/` partition. |
-| _`/usr/` Verity Signature Partition (ARC)_ | `94f9a9a1-9971-427a-a400-50cb297f0f35` `SD_GPT_USR_ARC_VERITY_SIG` | ditto | ditto |
-| _`/usr/` Verity Signature Partition (32-bit ARM)_ | `d7ff812f-37d1-4902-a810-d76ba57b975a` `SD_GPT_USR_ARM_VERITY_SIG` | ditto | ditto |
-| _`/usr/` Verity Signature Partition (64-bit ARM/AArch64)_ | `c23ce4ff-44bd-4b00-b2d4-b41b3419e02a` `SD_GPT_USR_ARM64_VERITY_SIG` | ditto | ditto |
-| _`/usr/` Verity Signature Partition (Itanium/IA-64)_ | `8de58bc2-2a43-460d-b14e-a76e4a17b47f` `SD_GPT_USR_IA64_VERITY_SIG` | ditto | ditto |
-| _`/usr/` Verity Signature Partition (LoongArch 64-bit)_ | `b024f315-d330-444c-8461-44bbde524e99` `SD_GPT_USR_LOONGARCH64_VERITY_SIG` | ditto | ditto |
-| _`/usr/` Verity Signature Partition (32-bit MIPS LittleEndian (mipsel))_ | `3e23ca0b-a4bc-4b4e-8087-5ab6a26aa8a9` `SD_GPT_USR_MIPS_LE_VERITY_SIG` | ditto | ditto |
-| _`/usr/` Verity Signature Partition (64-bit MIPS LittleEndian (mips64el))_ | `f2c2c7ee-adcc-4351-b5c6-ee9816b66e16` `SD_GPT_USR_MIPS64_LE_VERITY_SIG` | ditto | ditto |
-| _`/usr/` Verity Signature Partition (HPPA/PARISC)_ | `450dd7d1-3224-45ec-9cf2-a43a346d71ee` `SD_GPT_USR_PARISC_VERITY_SIG` | ditto | ditto |
-| _`/usr/` Verity Signature Partition (64-bit PowerPC LittleEndian)_ | `c8bfbd1e-268e-4521-8bba-bf314c399557` `SD_GPT_USR_PPC64_LE_VERITY_SIG` | ditto | ditto |
-| _`/usr/` Verity Signature Partition (64-bit PowerPC BigEndian)_ | `0b888863-d7f8-4d9e-9766-239fce4d58af` `SD_GPT_USR_PPC64_VERITY_SIG` | ditto | ditto |
-| _`/usr/` Verity Signature Partition (32-bit PowerPC)_ | `7007891d-d371-4a80-86a4-5cb875b9302e` `SD_GPT_USR_PPC_VERITY_SIG` | ditto | ditto |
-| _`/usr/` Verity Signature Partition (RISC-V 32-bit)_ | `c3836a13-3137-45ba-b583-b16c50fe5eb4` `SD_GPT_USR_RISCV32_VERITY_SIG` | ditto | ditto |
-| _`/usr/` Verity Signature Partition (RISC-V 64-bit)_ | `d2f9000a-7a18-453f-b5cd-4d32f77a7b32` `SD_GPT_USR_RISCV64_VERITY_SIG` | ditto | ditto |
-| _`/usr/` Verity Signature Partition (s390)_ | `17440e4f-a8d0-467f-a46e-3912ae6ef2c5` `SD_GPT_USR_S390_VERITY_SIG` | ditto | ditto |
-| _`/usr/` Verity Signature Partition (s390x)_ | `3f324816-667b-46ae-86ee-9b0c0c6c11b4` `SD_GPT_USR_S390X_VERITY_SIG` | ditto | ditto |
-| _`/usr/` Verity Signature Partition (TILE-Gx)_ | `4ede75e2-6ccc-4cc8-b9c7-70334b087510` `SD_GPT_USR_TILEGX_VERITY_SIG` | ditto | ditto |
-| _`/usr/` Verity Signature Partition (amd64/x86_64)_ | `e7bb33fb-06cf-4e81-8273-e543b413e2e2` `SD_GPT_USR_X86_64_VERITY_SIG` | ditto | ditto |
-| _`/usr/` Verity Signature Partition (x86)_ | `974a71c0-de41-43c3-be5d-5c5ccd1ad2c0` `SD_GPT_USR_X86_VERITY_SIG` | ditto | ditto |
-| _EFI System Partition_ | `c12a7328-f81f-11d2-ba4b-00a0c93ec93b` `SD_GPT_ESP` | VFAT | The ESP used for the current boot is automatically mounted to `/efi/` (or `/boot/` as fallback), unless a different partition is mounted there (possibly via `/etc/fstab`, or because the Extended Boot Loader Partition — see below — exists) or the directory is non-empty on the root disk.  This partition type is defined by the [UEFI Specification](http://www.uefi.org/specifications). |
-| _Extended Boot Loader Partition_ | `bc13c2ff-59e6-4262-a352-b275fd6f7172` `SD_GPT_XBOOTLDR` | Typically VFAT | The Extended Boot Loader Partition (XBOOTLDR) used for the current boot is automatically mounted to `/boot/`, unless a different partition is mounted there (possibly via `/etc/fstab`) or the directory is non-empty on the root disk. This partition type is defined by the [Boot Loader Specification](https://systemd.io/BOOT_LOADER_SPECIFICATION). |
-| _Swap_ | `0657fd6d-a4ab-43c4-84e5-0933c84b4f4f` `SD_GPT_SWAP` | Swap, optionally in LUKS | All swap partitions on the disk containing the root partition are automatically enabled. If the partition is encrypted with LUKS, the device mapper file will be named `/dev/mapper/swap`. This partition type predates the Discoverable Partitions Specification. |
-| _Home Partition_ | `933ac7e1-2eb4-4f13-b844-0e14e2aef915` `SD_GPT_HOME` | Any native, optionally in LUKS | The first partition with this type UUID on the disk containing the root partition is automatically mounted to `/home/`. If the partition is encrypted with LUKS, the device mapper file will be named `/dev/mapper/home`. |
-| _Server Data Partition_ | `3b8f8425-20e0-4f3b-907f-1a25a76f98e8` `SD_GPT_SRV` | Any native, optionally in LUKS | The first partition with this type UUID on the disk containing the root partition is automatically mounted to `/srv/`. If the partition is encrypted with LUKS, the device mapper file will be named `/dev/mapper/srv`. |
-| _Variable Data Partition_ | `4d21b016-b534-45c2-a9fb-5c16e091fd2d` `SD_GPT_VAR` | Any native, optionally in LUKS | The first partition with this type UUID on the disk containing the root partition is automatically mounted to `/var/` — under the condition that its partition UUID matches the first 128 bits of `HMAC-SHA256(machine-id, 0x4d21b016b53445c2a9fb5c16e091fd2d)` (i.e. the SHA256 HMAC hash of the binary type UUID keyed by the machine ID as read from [`/etc/machine-id`](https://www.freedesktop.org/software/systemd/man/machine-id.html). This special requirement is made because `/var/` (unlike the other partition types listed here) is inherently private to a specific installation and cannot possibly be shared between multiple OS installations on the same disk, and thus should be bound to a specific instance of the OS, identified by its machine ID. If the partition is encrypted with LUKS, the device mapper file will be named `/dev/mapper/var`. |
-| _Temporary Data Partition_ | `7ec6f557-3bc5-4aca-b293-16ef5df639d1` `SD_GPT_TMP` | Any native, optionally in LUKS | The first partition with this type UUID on the disk containing the root partition is automatically mounted to `/var/tmp/`. If the partition is encrypted with LUKS, the device mapper file will be named `/dev/mapper/tmp`. Note that the intended mount point is indeed `/var/tmp/`, not `/tmp/`. The latter is typically maintained in memory via `tmpfs` and does not require a partition on disk. In some cases it might be desirable to make `/tmp/` persistent too, in which case it is recommended to make it a symlink or bind mount to `/var/tmp/`, thus not requiring its own partition type UUID. |
-| _Per-user Home Partition_ | `773f91ef-66d4-49b5-bd83-d683bf40ad16` `SD_GPT_USER_HOME` | Any native, optionally in LUKS | A home partition of a user, managed by [`systemd-homed`](https://www.freedesktop.org/software/systemd/man/systemd-homed.html). |
-| _Generic Linux Data Partition_ | `0fc63daf-8483-4772-8e79-3d69d8477de4` `SD_GPT_LINUX_GENERIC` | Any native, optionally in LUKS | No automatic mounting takes place for other Linux data partitions. This partition type should be used for all partitions that carry Linux file systems. The installer needs to mount them explicitly via entries in `/etc/fstab`. Optionally, these partitions may be encrypted with LUKS. This partition type predates the Discoverable Partitions Specification. |
-
-Other GPT type IDs might be used on Linux, for example to mark software RAID or
-LVM partitions. The definitions of those GPT types is outside of the scope of
-this specification.
-
-[systemd-id128(1)](https://www.freedesktop.org/software/systemd/man/systemd-id128.html)'s
-`show` command may be used to list those GPT partition type UUIDs.
-
-## Partition Names
-
-For partitions of the types listed above it is recommended to use
-human-friendly, descriptive partition names in the GPT partition table, for
-example "*Home*", "*Server* *Data*", "*Fedora* *Root*" and similar, possibly
-localized.
-
-For the Root/Verity/Verity signature partitions it might make sense to use a
-versioned naming scheme reflecting the OS name and its version,
-e.g. "fooOS_2021.4" or similar.
-
-## Partition Attribute Flags
-
-This specification defines three GPT partition attribute flags that may be set
-for the partition types defined above:
-
-1. For the root, `/usr/`, Verity, Verity signature, home, server data, variable
-   data, temporary data, swap, and extended boot loader partitions, the
-   partition flag bit 63 ("*no-auto*", *SD_GPT_FLAG_NO_AUTO*) may be used to
-   turn off auto-discovery for the specific partition. If set, the partition
-   will not be automatically mounted or enabled.
-
-2. For the root, `/usr/`, Verity, Verity signature home, server data, variable
-   data, temporary data and extended boot loader partitions, the partition flag
-   bit 60 ("*read-only*", *SD_GPT_FLAG_READ_ONLY*) may be used to mark a
-   partition for read-only mounts only. If set, the partition will be mounted
-   read-only instead of read-write. Note that the variable data partition and
-   the temporary data partition will generally not be able to serve their
-   purpose if marked read-only, since by their very definition they are
-   supposed to be mutable. (The home and server data partitions are generally
-   assumed to be mutable as well, but the requirement for them is not equally
-   strong.) Because of that, while the read-only flag is defined and supported,
-   it's almost never a good idea to actually use it for these partitions. Also
-   note that Verity and signature partitions are by their semantics always
-   read-only. The flag is hence of little effect for them, and it is
-   recommended to set it unconditionally for the Verity and signature partition
-   types.
-
-3. For the root, `/usr/`, home, server data, variable data, temporary data and
-   extended boot loader partitions, the partition flag bit 59
-   ("*grow-file-system*", *SD_GPT_FLAG_GROWFS*) may be used to mark a partition
-   for automatic growing of the contained file system to the size of the
-   partition when mounted. Tools that automatically mount disk image with a GPT
-   partition table are suggested to implicitly grow the contained file system
-   to the partition size they are contained in, if they are found to be
-   smaller. This flag is without effect on partitions marked "*read-only*".
-
-Note that the first two flag definitions happen to correspond nicely to the
-same ones used by Microsoft Basic Data Partitions.
-
-All three of these flags generally affect only auto-discovery and automatic
-mounting of disk images. If partitions marked with these flags are mounted
-using low-level commands like
-[mount(8)](https://man7.org/linux/man-pages/man2/mount.8.html) or directly with
-[mount(2)](https://man7.org/linux/man-pages/man2/mount.2.html), they typically
-have no effect.
-
-## Verity
-
-The Root/`/usr/` partition types and their matching Verity and Verity signature
-partitions enable relatively automatic handling of `dm-verity` protected
-setups. These types are defined with two modes of operation in mind:
-
-1. A trusted Verity root hash is passed in externally, for example is specified
-   on the kernel command line that is signed along with the kernel image using
-   SecureBoot PE signing (which in turn is tested against a set of
-   firmware-provided set of signing keys). If so, discovery and setup of a
-   Verity volume may be fully automatic: if the root partition's UUID is chosen
-   to match the first 128 bit of the root hash, and the matching Verity
-   partition UUIDs is chosen to match the last 128bit of the root hash, then
-   automatic discovery and match-up of the two partitions is possible, as the
-   root hash is enough to both find the partitions and then combine them in a
-   Verity volume. In this mode a Verity signature partition is not used and
-   unnecessary.
-
-2. A Verity signature partition is included on the disk, with a signature to be
-   tested against a system-provided set of signing keys. The signature
-   partition primarily contains two fields: the root hash to use, and a PKCS#7
-   signature of it, using a signature key trusted by the OS. If so, discovery
-   and setup of a Verity volume may be fully automatic. First, the specified
-   root hash is validated with the signature and the OS-provided trusted
-   keys. If the signature checks out the root hash is then used in the same way
-   as in the first mode of operation described above.
-
-Both modes of operation may be combined in a single image. This is particularly
-useful for images that shall be usable in two different contexts: for example
-an image that shall be able to boot directly on UEFI systems (in which
-case it makes sense to include the root hash on the kernel command line that is
-included in the signed kernel image to boot, as per mode of operation #1
-above), but also be able to used as image for a container engine (such as
-`systemd-nspawn`), which can use the signature partition to validate the image,
-without making use of the signed kernel image (and thus following mode of
-operation #2).
-
-The Verity signature partition's contents should be a serialized JSON object in
-text form, padded with NUL bytes to the next multiple of 4096 bytes in
-size. Currently three fields are defined for the JSON object:
-
-1. The (mandatory) `rootHash` field should be a string containing the Verity root hash,
-   formatted as series of (lowercase) hex characters.
-
-2. The (mandatory) `signature` field should be a string containing the PKCS#7
-   signature of the root hash, in Base64-encoded DER format. This should be the
-   same format used by the Linux kernel's dm-verity signature logic, i.e. the
-   signed data should be the exact string representation of the hash, as stored
-   in `rootHash` above.
-
-3. The (optional) `certificateFingerprint` field should be a string containing
-   a SHA256 fingerprint of the X.509 certificate in DER format for the key that
-   signed the root hash, formatted as series of (lowercase) hex characters (no `:`
-   separators or such).
-
-More fields might be added in later revisions of this specification.
-
-## Suggested Mode of Operation
-
-An *installer* that repartitions the hard disk _should_ use the above UUID
-partition types for appropriate partitions it creates.
-
-An *installer* which supports a "manual partitioning" interface _may_ choose to
-pre-populate the interface with swap, `/home/`, `/srv/`, `/var/tmp/` partitions
-of pre-existing Linux installations, identified with the GPT type UUIDs
-above. The installer should not pre-populate such an interface with any
-identified root, `/usr` or `/var/` partition unless the intention is to
-overwrite an existing operating system that might be installed.
-
-An *installer* _may_ omit creating entries in `/etc/fstab` for root, `/home/`,
-`/srv/`, `/var/`, `/var/tmp` and for the swap partitions if they use these UUID
-partition types, and are the first partitions on the disk of each type. If the
-ESP shall be mounted to `/efi/` (or `/boot/`), it may additionally omit
-creating the entry for it in `/etc/fstab`.  If the EFI partition shall not be
-mounted to `/efi/` or `/boot/`, it _must_ create `/etc/fstab` entries for them.
-If other partitions are used (for example for `/usr/local/` or
-`/var/lib/mysql/`), the installer _must_ register these in `/etc/fstab`.  The
-`root=` parameter passed to the kernel by the boot loader may be omitted if the
-root partition is the first one on the disk of its type.  If the root partition
-is not the first one on the disk, the `root=` parameter _must_ be passed to the
-kernel by the boot loader.  An installer that mounts a root, `/usr/`, `/home/`,
-`/srv/`, `/var/`, or `/var/tmp/` file system with the partition types defined
-as above which contains a LUKS header _must_ call the device mapper device
-"root", "usr", "home", "srv", "var" or "tmp", respectively.  This is necessary
-to ensure that the automatic discovery will never result in different device
-mapper names than any static configuration by the installer, thus eliminating
-possible naming conflicts and ambiguities.
-
-An *operating* *system* _should_ automatically discover and mount the first
-root partition that does not have the no-auto flag set (as described above) by
-scanning the disk containing the currently used EFI ESP.  It _should_
-automatically discover and mount the first `/usr/`, `/home/`, `/srv/`, `/var/`,
-`/var/tmp/` and swap partitions that do not have the no-auto flag set by
-scanning the disk containing the discovered root partition.  It should
-automatically discover and mount the partition containing the currently used
-EFI ESP to `/efi/` (or `/boot/` as fallback).  It should automatically discover
-and mount the partition containing the currently used Extended Boot Loader
-Partition to `/boot/`. It _should not_ discover or automatically mount
-partitions with other UUID partition types, or partitions located on other
-disks, or partitions with the no-auto flag set.  User configuration shall
-always override automatic discovery and mounting.  If a root, `/usr/`,
-`/home/`, `/srv/`, `/boot/`, `/var/`, `/var/tmp/`, `/efi/`, `/boot/` or swap
-partition is listed in `/etc/fstab` or with `root=` on the kernel command line,
-it _must_ take precedence over automatically discovered partitions.  If a
-`/home/`, `/usr/`, `/srv/`, `/boot/`, `/var/`, `/var/tmp/`, `/efi/` or `/boot/`
-directory is found to be populated already in the root partition, the automatic
-discovery _must not_ mount any discovered file system over it. Optionally, in
-case of the root, `/usr/` and their Verity partitions instead of strictly
-mounting the first suitable partition an OS might choose to mount the partition
-whose label compares the highest according to `strverscmp()` or similar logic,
-in order to implement a simple partition-based A/B versioning scheme. The
-precise rules are left for the implementation to decide, but when in doubt
-earlier partitions (by their index) should always win over later partitions if
-the label comparison is inconclusive.
-
-A *container* *manager* should automatically discover and mount the root,
-`/usr/`, `/home/`, `/srv/`, `/var/`, `/var/tmp/` partitions inside a container
-disk image.  It may choose to mount any discovered ESP and/or XBOOTLDR
-partition to `/efi/` or `/boot/`. It should ignore any swap should they be
-included in a container disk image.
-
-If a btrfs file system is automatically discovered and mounted by the operating
-system/container manager it will be mounted with its *default* subvolume.  The
-installer should make sure to set the default subvolume correctly using "btrfs
-subvolume set-default".
-
-## Sharing of File Systems between Installations
-
-If two Linux-based operating systems are installed on the same disk, the scheme
-above suggests that they may share the swap, `/home/`, `/srv/`, `/var/tmp/`,
-ESP, XBOOTLDR. However, they should each have their own root, `/usr/` and
-`/var/` partition.
-
-## Frequently Asked Questions
-
-### Why are you taking my `/etc/fstab` away?
-
-We are not. `/etc/fstab` always overrides automatic discovery and is indeed
-mentioned in the specifications.  We are simply trying to make the boot and
-installation processes of Linux a bit more robust and self-descriptive.
-
-### Why did you only define the root partition for these listed architectures?
-
-Please submit a patch that adds appropriate partition type UUIDs for the
-architecture of your choice should they be missing so far. The only reason they
-aren't defined yet is that nobody submitted them yet.
-
-### Why define distinct root partition UUIDs for the various architectures?
-
-This allows disk images that may be booted on multiple architectures to use
-discovery of the appropriate root partition on each architecture.
-
-### Doesn't this break multi-boot scenarios?
-
-No, it doesn't.  The specification says that installers may not stop creating
-`/etc/fstab` or stop including `root=` on the kernel command line, unless the used
-partitions are the first ones of their type on the disk. Additionally,
-`/etc/fstab` and `root=` both override automatic discovery.  Multi-boot is hence
-well supported, since it doesn't change anything for anything but the first
-installation.
-
-That all said, it's not expected that generic installers generally stop setting
-`root=` and creating `/etc/fstab` anyway. The option to drop these configuration
-bits is primarily something for appliance-like devices.  However, generic
-installers should *still* set the right GPT partition types for the partitions
-they create so that container managers, partition tools and administrators can
-benefit.  Phrased differently, this specification introduces A) the
-*recommendation* to use the newly defined partition types to tag things
-properly and B) the *option* to then drop `root=` and `/etc/fstab`.  While we
-advertise A) to *all* installers, we only propose B) for simpler,
-appliance-like installations.
-
-### What partitioning tools will create a DPS-compliant partition table?
-
-As of util-linux 2.25.2, the `fdisk` tool provides type codes to create the
-root, home, and swap partitions that the DPS expects. By default, `fdisk` will
-create an old-style MBR, not a GPT, so typing `l` to list partition types will
-not show the choices to let you set the correct UUID. Make sure to first create
-an empty GPT, then type `l` in order for the DPS-compliant type codes to be
-available.
-
-The `gdisk` tool (from version 1.0.5 onward) and its variants (`sgdisk`,
-`cgdisk`) also support creation of partitions with a matching type code.
-
-## Links
-
-[Boot Loader Specification](BOOT_LOADER_SPECIFICATION.md)<br>
-[Boot Loader Interface](BOOT_LOADER_INTERFACE.md)<br>
-[Safely Building Images](BUILDING_IMAGES.md)<br>
-[`systemd-boot(7)`](https://www.freedesktop.org/software/systemd/man/systemd-boot.html)<br>
-[`bootctl(1)`](https://www.freedesktop.org/software/systemd/man/bootctl.html)<br>
-[`systemd-gpt-auto-generator(8)`](https://www.freedesktop.org/software/systemd/man/systemd-gpt-auto-generator.html)
+[This content has moved to the UAPI group website](https://uapi-group.org/specifications/specs/discoverable_partitions_specification/)
