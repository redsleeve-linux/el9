Only in binutils-2.35.2/binutils/: Makefile
diff -rup binutils.orig/binutils/NEWS binutils-2.35.2/binutils/NEWS
--- binutils.orig/binutils/NEWS	2021-08-16 13:07:33.383206365 +0100
+++ binutils-2.35.2/binutils/NEWS	2021-10-25 12:12:22.311951242 +0100
@@ -122,6 +122,15 @@ Changes in 2.32:
 
 Changes in 2.31:
 
+* Tools which display names or strings (readelf, strings, nm, objdump)
+  have a new command line option which controls how unicode characters are
+  handled.  By default they are treated as normal for the tool.  Using
+  --unicode=locale will display them according to the current locale.
+  Using --unicode=hex will display them as hex byte values, whilst
+  --unicode=escape will display them as escape sequences.  In addition
+  using --unicode=highlight will display them as unicode escape sequences
+  highlighted in red (if supported by the output device).
+
 * Add support for disassembling netronome Flow Processor (NFP) firmware files.
 
 * The AArch64 port now supports showing disassembly notes which are emitted
Only in binutils-2.35.2/binutils/: bucomm.o
Only in binutils-2.35.2/binutils/: config.cache
Only in binutils-2.35.2/binutils/: config.h
Only in binutils-2.35.2/binutils/: config.log
Only in binutils-2.35.2/binutils/: config.status
diff -rup binutils.orig/binutils/configure binutils-2.35.2/binutils/configure
--- binutils.orig/binutils/configure	2021-08-16 13:07:33.383206365 +0100
+++ binutils-2.35.2/binutils/configure	2021-10-25 12:12:24.344944672 +0100
@@ -1911,7 +1911,7 @@ else
 #ifdef __cplusplus
 extern "C"
 #endif
-char $2 ();
+__attribute__ ((used)) char $2 ();
 /* The GNU C library defines this for functions which it implements
     to always fail with ENOSYS.  Some functions are actually named
     something starting with __ and the normal name is an alias.  */
@@ -16118,7 +16118,7 @@ CFLAGS='`$ECHO "$CFLAGS" | $SED "$delay_
 compiler='`$ECHO "$compiler" | $SED "$delay_single_quote_subst"`'
 GCC='`$ECHO "$GCC" | $SED "$delay_single_quote_subst"`'
 lt_cv_sys_global_symbol_pipe='`$ECHO "$lt_cv_sys_global_symbol_pipe" | $SED "$delay_single_quote_subst"`'
-lt_cv_sys_global_symbol_to_cdecl='`$ECHO "$lt_cv_sys_global_symbol_to_cdecl" | $SED "$delay_single_quote_subst"`'
+lt_cv_sys_global_symbol_to_cdecl="sed -n -e 's/^T .* \(.*\)$/extern int \1();/p' -e 's/^$symcode* .* \(.*\)$/extern char \1;/p'"
 lt_cv_sys_global_symbol_to_c_name_address='`$ECHO "$lt_cv_sys_global_symbol_to_c_name_address" | $SED "$delay_single_quote_subst"`'
 lt_cv_sys_global_symbol_to_c_name_address_lib_prefix='`$ECHO "$lt_cv_sys_global_symbol_to_c_name_address_lib_prefix" | $SED "$delay_single_quote_subst"`'
 objdir='`$ECHO "$objdir" | $SED "$delay_single_quote_subst"`'
Only in binutils-2.35.2/binutils/: configure.backup
Only in binutils-2.35.2/binutils/doc: Makefile
diff -rup binutils.orig/binutils/doc/addr2line.1 binutils-2.35.2/binutils/doc/addr2line.1
--- binutils.orig/binutils/doc/addr2line.1	2021-08-16 13:07:33.366206472 +0100
+++ binutils-2.35.2/binutils/doc/addr2line.1	2021-10-25 12:13:31.293728313 +0100
@@ -1,4 +1,4 @@
-.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
+.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.42)
 .\"
 .\" Standard preamble:
 .\" ========================================================================
@@ -133,7 +133,7 @@
 .\" ========================================================================
 .\"
 .IX Title "ADDR2LINE 1"
-.TH ADDR2LINE 1 "2021-01-30" "binutils-2.35.2" "GNU Development Tools"
+.TH ADDR2LINE 1 "2021-10-25" "binutils-2.35.2" "GNU Development Tools"
 .\" For nroff, turn off justification.  Always turn off hyphenation; it makes
 .\" way too many mistakes in technical documents.
 .if n .ad l
diff -rup binutils.orig/binutils/doc/ar.1 binutils-2.35.2/binutils/doc/ar.1
--- binutils.orig/binutils/doc/ar.1	2021-08-16 13:07:33.366206472 +0100
+++ binutils-2.35.2/binutils/doc/ar.1	2021-10-25 12:13:31.317728235 +0100
@@ -1,4 +1,4 @@
-.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
+.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.42)
 .\"
 .\" Standard preamble:
 .\" ========================================================================
@@ -133,7 +133,7 @@
 .\" ========================================================================
 .\"
 .IX Title "AR 1"
-.TH AR 1 "2021-01-30" "binutils-2.35.2" "GNU Development Tools"
+.TH AR 1 "2021-10-25" "binutils-2.35.2" "GNU Development Tools"
 .\" For nroff, turn off justification.  Always turn off hyphenation; it makes
 .\" way too many mistakes in technical documents.
 .if n .ad l
diff -rup binutils.orig/binutils/doc/binutils.info binutils-2.35.2/binutils/doc/binutils.info
--- binutils.orig/binutils/doc/binutils.info	2021-08-16 13:07:33.366206472 +0100
+++ binutils-2.35.2/binutils/doc/binutils.info	2021-10-25 12:13:32.884723171 +0100
@@ -601,6 +601,7 @@ File: binutils.info,  Node: nm,  Next: o
         [-D|--dynamic] [-fFORMAT|--format=FORMAT]
         [-g|--extern-only] [-h|--help]
         [-l|--line-numbers] [--inlines]
+        [-U METHOD] [--unicode=METHOD]
         [-n|-v|--numeric-sort]
         [-P|--portability] [-p|--no-sort]
         [-r|--reverse-sort] [-S|--print-size]
@@ -867,6 +868,22 @@ equivalent.
      Display only undefined symbols (those external to each object
      file).
 
+'-U [D|I|L|E|X|H]'
+'--unicode=[DEFAULT|INVALID|LOCALE|ESCAPE|HEX|HIGHLIGHT]'
+     Controls the display of UTF-8 encoded mulibyte characters in
+     strings.  The default ('--unicode=default') is to give them no
+     special treatment.  The '--unicode=locale' option displays the
+     sequence in the current locale, which may or may not support them.
+     The options '--unicode=hex' and '--unicode=invalid' display them as
+     hex byte sequences enclosed by either angle brackets or curly
+     braces.
+
+     The '--unicode=escape' option displays them as escape sequences
+     (\UXXXX) and the '--unicode=highlight' option displays them as
+     escape sequences highlighted in red (if supported by the output
+     device).  The colouring is intended to draw attention to the
+     presence of unicode sequences where they might not be expected.
+
 '-V'
 '--version'
      Show the version number of 'nm' and exit.
@@ -1890,6 +1907,7 @@ File: binutils.info,  Node: objdump,  Ne
              [--prefix-strip=LEVEL]
              [--insn-width=WIDTH]
              [--visualize-jumps[=color|=extended-color|=off]
+             [-U METHOD] [--unicode=METHOD]
              [-V|--version]
              [-H|--help]
              OBJFILE...
@@ -2648,6 +2666,22 @@ given.
      be special in some way and which would not normally be of interest
      to the user.
 
+'-U [D|I|L|E|X|H]'
+'--unicode=[DEFAULT|INVALID|LOCALE|ESCAPE|HEX|HIGHLIGHT]'
+     Controls the display of UTF-8 encoded mulibyte characters in
+     strings.  The default ('--unicode=default') is to give them no
+     special treatment.  The '--unicode=locale' option displays the
+     sequence in the current locale, which may or may not support them.
+     The options '--unicode=hex' and '--unicode=invalid' display them as
+     hex byte sequences enclosed by either angle brackets or curly
+     braces.
+
+     The '--unicode=escape' option displays them as escape sequences
+     (\UXXXX) and the '--unicode=highlight' option displays them as
+     escape sequences highlighted in red (if supported by the output
+     device).  The colouring is intended to draw attention to the
+     presence of unicode sequences where they might not be expected.
+
 '-V'
 '--version'
      Print the version number of 'objdump' and exit.
@@ -2842,6 +2876,7 @@ File: binutils.info,  Node: strings,  Ne
              [-n MIN-LEN] [--bytes=MIN-LEN]
              [-t RADIX] [--radix=RADIX]
              [-e ENCODING] [--encoding=ENCODING]
+             [-U METHOD] [--unicode=METHOD]
              [-] [--all] [--print-file-name]
              [-T BFDNAME] [--target=BFDNAME]
              [-w] [--include-all-whitespace]
@@ -2924,6 +2959,27 @@ files.
      Useful for finding wide character strings.  ('l' and 'b' apply to,
      for example, Unicode UTF-16/UCS-2 encodings).
 
+'-U [D|I|L|E|X|H]'
+'--unicode=[DEFAULT|INVALID|LOCALE|ESCAPE|HEX|HIGHLIGHT]'
+     Controls the display of UTF-8 encoded mulibyte characters in
+     strings.  The default ('--unicode=default') is to give them no
+     special treatment, and instead rely upon the setting of the
+     '--encoding' option.  The other values for this option
+     automatically enable '--encoding=S'.
+
+     The '--unicode=invalid' option treats them as non-graphic
+     characters and hence not part of a valid string.  All the remaining
+     options treat them as valid string characters.
+
+     The '--unicode=locale' option displays them in the current locale,
+     which may or may not support UTF-8 encoding.  The '--unicode=hex'
+     option displays them as hex byte sequences enclosed between <>
+     characters.  The '--unicode=escape' option displays them as escape
+     sequences (\UXXXX) and the '--unicode=highlight' option displays
+     them as escape sequences highlighted in red (if supported by the
+     output device).  The colouring is intended to draw attention to the
+     presence of unicode sequences where they might not be expected.
+
 '-T BFDNAME'
 '--target=BFDNAME'
      Specify an object code format other than your system's default
@@ -4241,6 +4297,7 @@ File: binutils.info,  Node: readelf,  Ne
              [-W|--wide]
              [-T|--silent-truncation]
              [-H|--help]
+             [-U METHOD|--unicode=METHOD]
              ELFFILE...
 
    'readelf' displays information about one or more ELF format object
@@ -4310,6 +4367,28 @@ equivalent.  At least one option besides
      if it has one.  The output format is the same as the format used by
      the '--syms' option.
 
+'-U [D|I|L|E|X|H]'
+'--unicode=[default|invalid|locale|escape|hex|highlight]'
+     Controls the display of non-ASCII characters in identifier names.
+     The default ('--unicode=locale' or '--unicode=default') is to treat
+     them as multibyte characters and display them in the current
+     locale.  All other versions of this option treat the bytes as UTF-8
+     encoded values and attempt to interpret them.  If they cannot be
+     interpreted or if the '--unicode=invalid' option is used then they
+     are displayed as a sequence of hex bytes, encloses in curly
+     parethesis characters.
+
+     Using the '--unicode=escape' option will display the characters as
+     as unicode escape sequences (\UXXXX).  Using the '--unicode=hex'
+     will display the characters as hex byte sequences enclosed between
+     angle brackets.
+
+     Using the '--unicode=highlight' will display the characters as
+     unicode escape sequences but it will also highlighted them in red,
+     assuming that colouring is supported by the output device.  The
+     colouring is intended to draw attention to the presence of unicode
+     sequences when they might not be expected.
+
 '-e'
 '--headers'
      Display all the headers in the file.  Equivalent to '-h -l -S'.
@@ -5549,18 +5628,18 @@ Binutils Index
 * -enable-deterministic-archives <5>:    ranlib.              (line  44)
 * -enable-deterministic-archives <6>:    strip.               (line 155)
 * -enable-deterministic-archives <7>:    strip.               (line 165)
-* .stab:                                 objdump.             (line 696)
-* Add prefix to absolute paths:          objdump.             (line 505)
+* .stab:                                 objdump.             (line 697)
+* Add prefix to absolute paths:          objdump.             (line 506)
 * addr2line:                             addr2line.           (line   6)
 * address to file name and line number:  addr2line.           (line   6)
-* all header information, object file:   objdump.             (line 818)
+* all header information, object file:   objdump.             (line 835)
 * ar:                                    ar.                  (line   6)
 * ar compatibility:                      ar.                  (line  60)
-* architecture:                          objdump.             (line 257)
-* architectures available:               objdump.             (line 242)
+* architecture:                          objdump.             (line 258)
+* architectures available:               objdump.             (line 243)
 * archive contents:                      ranlib.              (line   6)
-* Archive file symbol index information: readelf.             (line 194)
-* archive headers:                       objdump.             (line  75)
+* Archive file symbol index information: readelf.             (line 217)
+* archive headers:                       objdump.             (line  76)
 * archives:                              ar.                  (line   6)
 * base files:                            dlltool.             (line 124)
 * bug criteria:                          Bug Criteria.        (line   6)
@@ -5574,23 +5653,23 @@ Binutils Index
 * changing section VMA:                  objcopy.             (line 434)
 * changing start address:                objcopy.             (line 396)
 * collections of files:                  ar.                  (line   6)
-* Compact Type Format:                   objdump.             (line 682)
-* Compact Type Format <1>:               readelf.             (line 342)
+* Compact Type Format:                   objdump.             (line 683)
+* Compact Type Format <1>:               readelf.             (line 365)
 * compatibility, ar:                     ar.                  (line  60)
 * contents of archive:                   ar cmdline.          (line  97)
 * crash:                                 Bug Criteria.        (line   9)
 * creating archives:                     ar cmdline.          (line 144)
 * creating thin archive:                 ar cmdline.          (line 219)
-* CTF:                                   objdump.             (line 682)
-* CTF <1>:                               readelf.             (line 342)
+* CTF:                                   objdump.             (line 683)
+* CTF <1>:                               readelf.             (line 365)
 * cxxfilt:                               c++filt.             (line  16)
 * dates in archive:                      ar cmdline.          (line 183)
-* debug symbols:                         objdump.             (line 696)
-* debugging symbols:                     nm.                  (line 160)
+* debug symbols:                         objdump.             (line 697)
+* debugging symbols:                     nm.                  (line 161)
 * deleting from archive:                 ar cmdline.          (line  26)
 * demangling C++ symbols:                c++filt.             (line   6)
-* demangling in nm:                      nm.                  (line 168)
-* demangling in objdump:                 objdump.             (line 103)
+* demangling in nm:                      nm.                  (line 169)
+* demangling in objdump:                 objdump.             (line 104)
 * demangling in objdump <1>:             addr2line.           (line  86)
 * deterministic archives:                ar cmdline.          (line 150)
 * deterministic archives <1>:            ar cmdline.          (line 233)
@@ -5600,73 +5679,73 @@ Binutils Index
 * deterministic archives <5>:            ranlib.              (line  44)
 * deterministic archives <6>:            strip.               (line 155)
 * deterministic archives <7>:            strip.               (line 165)
-* disassembling object code:             objdump.             (line 144)
-* disassembly architecture:              objdump.             (line 257)
-* disassembly endianness:                objdump.             (line 192)
-* disassembly, with source:              objdump.             (line 494)
-* disassembly, with source <1>:          objdump.             (line 498)
+* disassembling object code:             objdump.             (line 145)
+* disassembly architecture:              objdump.             (line 258)
+* disassembly endianness:                objdump.             (line 193)
+* disassembly, with source:              objdump.             (line 495)
+* disassembly, with source <1>:          objdump.             (line 499)
 * discarding symbols:                    strip.               (line   6)
 * DLL:                                   dlltool.             (line   6)
 * dlltool:                               dlltool.             (line   6)
-* dynamic relocation entries, in object file: objdump.        (line 482)
-* dynamic symbol table entries, printing: objdump.            (line 795)
-* dynamic symbols:                       nm.                  (line 198)
-* ELF dynamic section information:       readelf.             (line 134)
-* ELF dynamic symbol table information:  readelf.             (line 106)
-* ELF file header information:           readelf.             (line  69)
+* dynamic relocation entries, in object file: objdump.        (line 483)
+* dynamic symbol table entries, printing: objdump.            (line 796)
+* dynamic symbols:                       nm.                  (line 199)
+* ELF dynamic section information:       readelf.             (line 157)
+* ELF dynamic symbol table information:  readelf.             (line 107)
+* ELF file header information:           readelf.             (line  70)
 * ELF file information:                  readelf.             (line   6)
-* ELF notes:                             readelf.             (line 116)
-* ELF object file format:                objdump.             (line 696)
-* ELF program header information:        readelf.             (line  75)
-* ELF reloc information:                 readelf.             (line 120)
-* ELF section group information:         readelf.             (line  86)
-* ELF section information:               readelf.             (line  81)
-* ELF section information <1>:           readelf.             (line  91)
-* ELF segment information:               readelf.             (line  75)
-* ELF symbol table information:          readelf.             (line  96)
-* ELF version sections information:      readelf.             (line 138)
+* ELF notes:                             readelf.             (line 139)
+* ELF object file format:                objdump.             (line 697)
+* ELF program header information:        readelf.             (line  76)
+* ELF reloc information:                 readelf.             (line 143)
+* ELF section group information:         readelf.             (line  87)
+* ELF section information:               readelf.             (line  82)
+* ELF section information <1>:           readelf.             (line  92)
+* ELF segment information:               readelf.             (line  76)
+* ELF symbol table information:          readelf.             (line  97)
+* ELF version sections information:      readelf.             (line 161)
 * elfedit:                               elfedit.             (line   6)
-* endianness:                            objdump.             (line 192)
+* endianness:                            objdump.             (line 193)
 * error on valid input:                  Bug Criteria.        (line  12)
-* external symbols:                      nm.                  (line 210)
-* external symbols <1>:                  nm.                  (line 274)
-* external symbols <2>:                  nm.                  (line 288)
+* external symbols:                      nm.                  (line 211)
+* external symbols <1>:                  nm.                  (line 275)
+* external symbols <2>:                  nm.                  (line 305)
 * extract from archive:                  ar cmdline.          (line 114)
 * fatal signal:                          Bug Criteria.        (line   9)
-* file name:                             nm.                  (line 154)
-* header information, all:               objdump.             (line 818)
+* file name:                             nm.                  (line 155)
+* header information, all:               objdump.             (line 835)
 * input .def file:                       dlltool.             (line 120)
-* input file name:                       nm.                  (line 154)
-* Instruction width:                     objdump.             (line 522)
+* input file name:                       nm.                  (line 155)
+* Instruction width:                     objdump.             (line 523)
 * libraries:                             ar.                  (line  25)
 * listings strings:                      strings.             (line   6)
-* machine instructions:                  objdump.             (line 144)
+* machine instructions:                  objdump.             (line 145)
 * moving in archive:                     ar cmdline.          (line  34)
 * MRI compatibility, ar:                 ar scripts.          (line   8)
 * name duplication in archive:           ar cmdline.          (line 108)
 * name length:                           ar.                  (line  18)
 * nm:                                    nm.                  (line   6)
-* nm compatibility:                      nm.                  (line 164)
-* nm compatibility <1>:                  nm.                  (line 204)
-* nm format:                             nm.                  (line 164)
-* nm format <1>:                         nm.                  (line 204)
+* nm compatibility:                      nm.                  (line 165)
+* nm compatibility <1>:                  nm.                  (line 205)
+* nm format:                             nm.                  (line 165)
+* nm format <1>:                         nm.                  (line 205)
 * not writing archive index:             ar cmdline.          (line 212)
 * objdump:                               objdump.             (line   6)
-* objdump inlines:                       nm.                  (line 226)
-* object code format:                    nm.                  (line 332)
-* object code format <1>:                objdump.             (line  89)
+* objdump inlines:                       nm.                  (line 227)
+* object code format:                    nm.                  (line 349)
+* object code format <1>:                objdump.             (line  90)
 * object code format <2>:                size.                (line 103)
-* object code format <3>:                strings.             (line  94)
+* object code format <3>:                strings.             (line 116)
 * object code format <4>:                addr2line.           (line  81)
-* object file header:                    objdump.             (line 198)
+* object file header:                    objdump.             (line 199)
 * object file information:               objdump.             (line   6)
-* object file offsets:                   objdump.             (line 203)
-* object file sections:                  objdump.             (line 489)
-* object formats available:              objdump.             (line 242)
+* object file offsets:                   objdump.             (line 204)
+* object file sections:                  objdump.             (line 490)
+* object formats available:              objdump.             (line 243)
 * offsets of files:                      ar cmdline.          (line 188)
 * operations on archive:                 ar cmdline.          (line  22)
 * plugins:                               ar cmdline.          (line 267)
-* plugins <1>:                           nm.                  (line 291)
+* plugins <1>:                           nm.                  (line 308)
 * printing from archive:                 ar cmdline.          (line  46)
 * printing strings:                      strings.             (line   6)
 * quick append to archive:               ar cmdline.          (line  54)
@@ -5675,51 +5754,51 @@ Binutils Index
 * ranlib <1>:                            ar cmdline.          (line  91)
 * readelf:                               readelf.             (line   6)
 * relative placement in archive:         ar cmdline.          (line 132)
-* relocation entries, in object file:    objdump.             (line 476)
+* relocation entries, in object file:    objdump.             (line 477)
 * removing symbols:                      strip.               (line   6)
 * repeated names in archive:             ar cmdline.          (line 108)
 * replacement in archive:                ar cmdline.          (line  73)
 * reporting bugs:                        Reporting Bugs.      (line   6)
 * scripts, ar:                           ar scripts.          (line   8)
-* section addresses in objdump:          objdump.             (line  81)
-* section headers:                       objdump.             (line 219)
-* section information:                   objdump.             (line 247)
+* section addresses in objdump:          objdump.             (line  82)
+* section headers:                       objdump.             (line 220)
+* section information:                   objdump.             (line 248)
 * section sizes:                         size.                (line   6)
-* sections, full contents:               objdump.             (line 489)
+* sections, full contents:               objdump.             (line 490)
 * separate debug files:                  debuginfod.          (line   6)
 * size:                                  size.                (line   6)
 * size display format:                   size.                (line  28)
 * size number format:                    size.                (line  85)
-* sorting symbols:                       nm.                  (line 241)
-* source code context:                   objdump.             (line 212)
-* source disassembly:                    objdump.             (line 494)
-* source disassembly <1>:                objdump.             (line 498)
-* source file name:                      nm.                  (line 154)
-* source filenames for object files:     objdump.             (line 251)
-* stab:                                  objdump.             (line 696)
-* start-address:                         objdump.             (line 705)
-* stop-address:                          objdump.             (line 709)
+* sorting symbols:                       nm.                  (line 242)
+* source code context:                   objdump.             (line 213)
+* source disassembly:                    objdump.             (line 495)
+* source disassembly <1>:                objdump.             (line 499)
+* source file name:                      nm.                  (line 155)
+* source filenames for object files:     objdump.             (line 252)
+* stab:                                  objdump.             (line 697)
+* start-address:                         objdump.             (line 706)
+* stop-address:                          objdump.             (line 710)
 * strings:                               strings.             (line   6)
 * strings, printing:                     strings.             (line   6)
 * strip:                                 strip.               (line   6)
-* Strip absolute paths:                  objdump.             (line 508)
+* Strip absolute paths:                  objdump.             (line 509)
 * symbol index:                          ar.                  (line  28)
 * symbol index <1>:                      ranlib.              (line   6)
-* symbol index, listing:                 nm.                  (line 263)
-* symbol line numbers:                   nm.                  (line 218)
-* symbol table entries, printing:        objdump.             (line 714)
+* symbol index, listing:                 nm.                  (line 264)
+* symbol line numbers:                   nm.                  (line 219)
+* symbol table entries, printing:        objdump.             (line 715)
 * symbols:                               nm.                  (line   6)
 * symbols, discarding:                   strip.               (line   6)
 * thin archives:                         ar.                  (line  40)
-* undefined symbols:                     nm.                  (line 274)
-* undefined symbols <1>:                 nm.                  (line 288)
+* undefined symbols:                     nm.                  (line 275)
+* undefined symbols <1>:                 nm.                  (line 305)
 * Unix compatibility, ar:                ar cmdline.          (line   8)
-* unwind information:                    readelf.             (line 125)
+* unwind information:                    readelf.             (line 148)
 * Update ELF header:                     elfedit.             (line   6)
 * updating an archive:                   ar cmdline.          (line 224)
 * version:                               Top.                 (line   6)
-* VMA in objdump:                        objdump.             (line  81)
-* wide output, printing:                 objdump.             (line 824)
+* VMA in objdump:                        objdump.             (line  82)
+* wide output, printing:                 objdump.             (line 841)
 * writing archive index:                 ar cmdline.          (line 206)
 
 
@@ -5730,31 +5809,31 @@ Node: ar3553
 Node: ar cmdline6706
 Node: ar scripts19332
 Node: nm25018
-Node: objcopy37699
-Node: objdump78192
-Node: ranlib111217
-Node: size112816
-Node: strings116785
-Node: strip121157
-Node: c++filt130682
-Ref: c++filt-Footnote-1136544
-Node: addr2line136650
-Node: windmc142329
-Node: windres145988
-Node: dlltool152347
-Node: def file format165344
-Node: readelf167874
-Node: elfedit181388
-Node: Common Options184344
-Node: Selecting the Target System185378
-Node: Target Selection186306
-Node: Architecture Selection188287
-Node: debuginfod189115
-Node: Reporting Bugs189874
-Node: Bug Criteria190636
-Node: Bug Reporting191189
-Node: GNU Free Documentation License198059
-Node: Binutils Index223219
+Node: objcopy38585
+Node: objdump79078
+Node: ranlib112994
+Node: size114593
+Node: strings118562
+Node: strip124112
+Node: c++filt133637
+Ref: c++filt-Footnote-1139499
+Node: addr2line139605
+Node: windmc145284
+Node: windres148943
+Node: dlltool155302
+Node: def file format168299
+Node: readelf170829
+Node: elfedit185547
+Node: Common Options188503
+Node: Selecting the Target System189537
+Node: Target Selection190465
+Node: Architecture Selection192446
+Node: debuginfod193274
+Node: Reporting Bugs194033
+Node: Bug Criteria194795
+Node: Bug Reporting195348
+Node: GNU Free Documentation License202218
+Node: Binutils Index227378
 
 End Tag Table
 
diff -rup binutils.orig/binutils/doc/binutils.texi binutils-2.35.2/binutils/doc/binutils.texi
--- binutils.orig/binutils/doc/binutils.texi	2021-08-16 13:07:33.366206472 +0100
+++ binutils-2.35.2/binutils/doc/binutils.texi	2021-10-25 12:12:22.312951239 +0100
@@ -787,6 +787,7 @@ nm [@option{-A}|@option{-o}|@option{--pr
    [@option{-D}|@option{--dynamic}] [@option{-f}@var{format}|@option{--format=}@var{format}]
    [@option{-g}|@option{--extern-only}] [@option{-h}|@option{--help}]
    [@option{-l}|@option{--line-numbers}] [@option{--inlines}]
+   [@option{-U} @var{method}] [@option{--unicode=}@var{method}]
    [@option{-n}|@option{-v}|@option{--numeric-sort}]
    [@option{-P}|@option{--portability}] [@option{-p}|@option{--no-sort}]
    [@option{-r}|@option{--reverse-sort}] [@option{-S}|@option{--print-size}]
@@ -1081,6 +1082,21 @@ Use @var{radix} as the radix for printin
 @cindex undefined symbols
 Display only undefined symbols (those external to each object file).
 
+@item -U @var{[d|i|l|e|x|h]}
+@itemx --unicode=@var{[default|invalid|locale|escape|hex|highlight]}
+Controls the display of UTF-8 encoded mulibyte characters in strings.
+The default (@option{--unicode=default}) is to give them no special
+treatment.  The @option{--unicode=locale} option displays the sequence
+in the current locale, which may or may not support them.  The options
+@option{--unicode=hex} and @option{--unicode=invalid} display them as
+hex byte sequences enclosed by either angle brackets or curly braces.
+
+The @option{--unicode=escape} option displays them as escape sequences
+(@var{\uxxxx}) and the @option{--unicode=highlight} option displays
+them as escape sequences highlighted in red (if supported by the
+output device).  The colouring is intended to draw attention to the
+presence of unicode sequences where they might not be expected.
+
 @item -V
 @itemx --version
 Show the version number of @command{nm} and exit.
@@ -2174,6 +2190,7 @@ objdump [@option{-a}|@option{--archive-h
         [@option{--prefix-strip=}@var{level}]
         [@option{--insn-width=}@var{width}]
         [@option{--visualize-jumps[=color|=extended-color|=off]}
+        [@option{-U} @var{method}] [@option{--unicode=}@var{method}]
         [@option{-V}|@option{--version}]
         [@option{-H}|@option{--help}]
         @var{objfile}@dots{}
@@ -2841,6 +2858,21 @@ When displaying symbols include those wh
 special in some way and which would not normally be of interest to the
 user.
 
+@item -U @var{[d|i|l|e|x|h]}
+@itemx --unicode=@var{[default|invalid|locale|escape|hex|highlight]}
+Controls the display of UTF-8 encoded mulibyte characters in strings.
+The default (@option{--unicode=default}) is to give them no special
+treatment.  The @option{--unicode=locale} option displays the sequence
+in the current locale, which may or may not support them.  The options
+@option{--unicode=hex} and @option{--unicode=invalid} display them as
+hex byte sequences enclosed by either angle brackets or curly braces.
+
+The @option{--unicode=escape} option displays them as escape sequences
+(@var{\uxxxx}) and the @option{--unicode=highlight} option displays
+them as escape sequences highlighted in red (if supported by the
+output device).  The colouring is intended to draw attention to the
+presence of unicode sequences where they might not be expected.
+
 @item -V
 @itemx --version
 Print the version number of @command{objdump} and exit.
@@ -3117,6 +3149,7 @@ strings [@option{-afovV}] [@option{-}@va
         [@option{-n} @var{min-len}] [@option{--bytes=}@var{min-len}]
         [@option{-t} @var{radix}] [@option{--radix=}@var{radix}]
         [@option{-e} @var{encoding}] [@option{--encoding=}@var{encoding}]
+        [@option{-U} @var{method}] [@option{--unicode=}@var{method}]
         [@option{-}] [@option{--all}] [@option{--print-file-name}]
         [@option{-T} @var{bfdname}] [@option{--target=}@var{bfdname}]
         [@option{-w}] [@option{--include-all-whitespace}]
@@ -3208,6 +3241,28 @@ single-8-bit-byte characters, @samp{b} =
 littleendian.  Useful for finding wide character strings. (@samp{l}
 and @samp{b} apply to, for example, Unicode UTF-16/UCS-2 encodings).
 
+@item -U @var{[d|i|l|e|x|h]}
+@itemx --unicode=@var{[default|invalid|locale|escape|hex|highlight]}
+Controls the display of UTF-8 encoded mulibyte characters in strings.
+The default (@option{--unicode=default}) is to give them no special
+treatment, and instead rely upon the setting of the
+@option{--encoding} option.  The other values for this option
+automatically enable @option{--encoding=S}.
+
+The @option{--unicode=invalid} option treats them as non-graphic
+characters and hence not part of a valid string.  All the remaining
+options treat them as valid string characters.
+
+The @option{--unicode=locale} option displays them in the current
+locale, which may or may not support UTF-8 encoding.  The
+@option{--unicode=hex} option displays them as hex byte sequences
+enclosed between @var{<>} characters.  The @option{--unicode=escape}
+option displays them as escape sequences (@var{\uxxxx}) and the
+@option{--unicode=highlight} option displays them as escape sequences
+highlighted in red (if supported by the output device).  The colouring
+is intended to draw attention to the presence of unicode sequences
+where they might not be expected.
+
 @item -T @var{bfdname}
 @itemx --target=@var{bfdname}
 @cindex object code format
@@ -4726,6 +4781,7 @@ readelf [@option{-a}|@option{--all}]
         [@option{-W}|@option{--wide}]
         [@option{-T}|@option{--silent-truncation}]
         [@option{-H}|@option{--help}]
+        [@option{-U} @var{method}|@option{--unicode=}@var{method}]
         @var{elffile}@dots{}
 @c man end
 @end smallexample
@@ -4815,6 +4871,28 @@ Displays the entries in dynamic symbol t
 has one.  The output format is the same as the format used by the
 @option{--syms} option.
 
+@item -U @var{[d|i|l|e|x|h]}
+@itemx --unicode=[default|invalid|locale|escape|hex|highlight]
+Controls the display of non-ASCII characters in identifier names.
+The default (@option{--unicode=locale} or @option{--unicode=default}) is
+to treat them as multibyte characters and display them in the current
+locale.  All other versions of this option treat the bytes as UTF-8
+encoded values and attempt to interpret them.  If they cannot be
+interpreted or if the @option{--unicode=invalid} option is used then
+they are displayed as a sequence of hex bytes, encloses in curly
+parethesis characters.
+
+Using the @option{--unicode=escape} option will display the characters
+as as unicode escape sequences (@var{\uxxxx}).  Using the
+@option{--unicode=hex} will display the characters as hex byte
+sequences enclosed between angle brackets.
+
+Using the @option{--unicode=highlight} will display the characters as 
+unicode escape sequences but it will also highlighted them in red,
+assuming that colouring is supported by the output device.  The
+colouring is intended to draw attention to the presence of unicode
+sequences when they might not be expected.
+
 @item -e
 @itemx --headers
 Display all the headers in the file.  Equivalent to @option{-h -l -S}.
diff -rup binutils.orig/binutils/doc/c++filt.1 binutils-2.35.2/binutils/doc/c++filt.1
--- binutils.orig/binutils/doc/c++filt.1	2021-08-16 13:07:33.366206472 +0100
+++ binutils-2.35.2/binutils/doc/c++filt.1	2021-10-25 12:13:31.698727004 +0100
@@ -1,4 +1,4 @@
-.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
+.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.42)
 .\"
 .\" Standard preamble:
 .\" ========================================================================
@@ -133,7 +133,7 @@
 .\" ========================================================================
 .\"
 .IX Title "C++FILT 1"
-.TH C++FILT 1 "2021-01-30" "binutils-2.35.2" "GNU Development Tools"
+.TH C++FILT 1 "2021-10-25" "binutils-2.35.2" "GNU Development Tools"
 .\" For nroff, turn off justification.  Always turn off hyphenation; it makes
 .\" way too many mistakes in technical documents.
 .if n .ad l
diff -rup binutils.orig/binutils/doc/cxxfilt.man binutils-2.35.2/binutils/doc/cxxfilt.man
--- binutils.orig/binutils/doc/cxxfilt.man	2021-08-16 13:07:33.366206472 +0100
+++ binutils-2.35.2/binutils/doc/cxxfilt.man	2021-10-25 12:13:31.495727660 +0100
@@ -1,4 +1,4 @@
-.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
+.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.42)
 .\"
 .\" Standard preamble:
 .\" ========================================================================
@@ -133,7 +133,7 @@
 .\" ========================================================================
 .\"
 .IX Title "C++FILT 1"
-.TH C++FILT 1 "2021-01-30" "binutils-2.35.2" "GNU Development Tools"
+.TH C++FILT 1 "2021-10-25" "binutils-2.35.2" "GNU Development Tools"
 .\" For nroff, turn off justification.  Always turn off hyphenation; it makes
 .\" way too many mistakes in technical documents.
 .if n .ad l
diff -rup binutils.orig/binutils/doc/dlltool.1 binutils-2.35.2/binutils/doc/dlltool.1
--- binutils.orig/binutils/doc/dlltool.1	2021-08-16 13:07:33.366206472 +0100
+++ binutils-2.35.2/binutils/doc/dlltool.1	2021-10-25 12:13:31.308728264 +0100
@@ -1,4 +1,4 @@
-.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
+.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.42)
 .\"
 .\" Standard preamble:
 .\" ========================================================================
@@ -133,7 +133,7 @@
 .\" ========================================================================
 .\"
 .IX Title "DLLTOOL 1"
-.TH DLLTOOL 1 "2021-01-30" "binutils-2.35.2" "GNU Development Tools"
+.TH DLLTOOL 1 "2021-10-25" "binutils-2.35.2" "GNU Development Tools"
 .\" For nroff, turn off justification.  Always turn off hyphenation; it makes
 .\" way too many mistakes in technical documents.
 .if n .ad l
diff -rup binutils.orig/binutils/doc/elfedit.1 binutils-2.35.2/binutils/doc/elfedit.1
--- binutils.orig/binutils/doc/elfedit.1	2021-08-16 13:07:33.366206472 +0100
+++ binutils-2.35.2/binutils/doc/elfedit.1	2021-10-25 12:13:31.427727880 +0100
@@ -1,4 +1,4 @@
-.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
+.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.42)
 .\"
 .\" Standard preamble:
 .\" ========================================================================
@@ -133,7 +133,7 @@
 .\" ========================================================================
 .\"
 .IX Title "ELFEDIT 1"
-.TH ELFEDIT 1 "2021-01-30" "binutils-2.35.2" "GNU Development Tools"
+.TH ELFEDIT 1 "2021-10-25" "binutils-2.35.2" "GNU Development Tools"
 .\" For nroff, turn off justification.  Always turn off hyphenation; it makes
 .\" way too many mistakes in technical documents.
 .if n .ad l
diff -rup binutils.orig/binutils/doc/nm.1 binutils-2.35.2/binutils/doc/nm.1
--- binutils.orig/binutils/doc/nm.1	2021-08-16 13:07:33.366206472 +0100
+++ binutils-2.35.2/binutils/doc/nm.1	2021-10-25 12:13:31.322728219 +0100
@@ -1,4 +1,4 @@
-.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
+.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.42)
 .\"
 .\" Standard preamble:
 .\" ========================================================================
@@ -133,7 +133,7 @@
 .\" ========================================================================
 .\"
 .IX Title "NM 1"
-.TH NM 1 "2021-01-30" "binutils-2.35.2" "GNU Development Tools"
+.TH NM 1 "2021-10-25" "binutils-2.35.2" "GNU Development Tools"
 .\" For nroff, turn off justification.  Always turn off hyphenation; it makes
 .\" way too many mistakes in technical documents.
 .if n .ad l
@@ -147,6 +147,7 @@ nm [\fB\-A\fR|\fB\-o\fR|\fB\-\-print\-fi
    [\fB\-D\fR|\fB\-\-dynamic\fR] [\fB\-f\fR\fIformat\fR|\fB\-\-format=\fR\fIformat\fR]
    [\fB\-g\fR|\fB\-\-extern\-only\fR] [\fB\-h\fR|\fB\-\-help\fR]
    [\fB\-l\fR|\fB\-\-line\-numbers\fR] [\fB\-\-inlines\fR]
+   [\fB\-U\fR \fImethod\fR] [\fB\-\-unicode=\fR\fImethod\fR]
    [\fB\-n\fR|\fB\-v\fR|\fB\-\-numeric\-sort\fR]
    [\fB\-P\fR|\fB\-\-portability\fR] [\fB\-p\fR|\fB\-\-no\-sort\fR]
    [\fB\-r\fR|\fB\-\-reverse\-sort\fR] [\fB\-S\fR|\fB\-\-print\-size\fR]
@@ -514,6 +515,24 @@ Use \fIradix\fR as the radix for printin
 .IX Item "--undefined-only"
 .PD
 Display only undefined symbols (those external to each object file).
+.IP "\fB\-U\fR \fI[d|i|l|e|x|h]\fR" 4
+.IX Item "-U [d|i|l|e|x|h]"
+.PD 0
+.IP "\fB\-\-unicode=\fR\fI[default|invalid|locale|escape|hex|highlight]\fR" 4
+.IX Item "--unicode=[default|invalid|locale|escape|hex|highlight]"
+.PD
+Controls the display of \s-1UTF\-8\s0 encoded mulibyte characters in strings.
+The default (\fB\-\-unicode=default\fR) is to give them no special
+treatment.  The \fB\-\-unicode=locale\fR option displays the sequence
+in the current locale, which may or may not support them.  The options
+\&\fB\-\-unicode=hex\fR and \fB\-\-unicode=invalid\fR display them as
+hex byte sequences enclosed by either angle brackets or curly braces.
+.Sp
+The \fB\-\-unicode=escape\fR option displays them as escape sequences
+(\fI\euxxxx\fR) and the \fB\-\-unicode=highlight\fR option displays
+them as escape sequences highlighted in red (if supported by the
+output device).  The colouring is intended to draw attention to the
+presence of unicode sequences where they might not be expected.
 .IP "\fB\-V\fR" 4
 .IX Item "-V"
 .PD 0
diff -rup binutils.orig/binutils/doc/objcopy.1 binutils-2.35.2/binutils/doc/objcopy.1
--- binutils.orig/binutils/doc/objcopy.1	2021-08-16 13:07:33.366206472 +0100
+++ binutils-2.35.2/binutils/doc/objcopy.1	2021-10-25 12:13:31.363728087 +0100
@@ -1,4 +1,4 @@
-.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
+.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.42)
 .\"
 .\" Standard preamble:
 .\" ========================================================================
@@ -133,7 +133,7 @@
 .\" ========================================================================
 .\"
 .IX Title "OBJCOPY 1"
-.TH OBJCOPY 1 "2021-01-30" "binutils-2.35.2" "GNU Development Tools"
+.TH OBJCOPY 1 "2021-10-25" "binutils-2.35.2" "GNU Development Tools"
 .\" For nroff, turn off justification.  Always turn off hyphenation; it makes
 .\" way too many mistakes in technical documents.
 .if n .ad l
diff -rup binutils.orig/binutils/doc/objdump.1 binutils-2.35.2/binutils/doc/objdump.1
--- binutils.orig/binutils/doc/objdump.1	2021-08-16 13:07:33.366206472 +0100
+++ binutils-2.35.2/binutils/doc/objdump.1	2021-10-25 12:13:31.370728064 +0100
@@ -1,4 +1,4 @@
-.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
+.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.42)
 .\"
 .\" Standard preamble:
 .\" ========================================================================
@@ -133,7 +133,7 @@
 .\" ========================================================================
 .\"
 .IX Title "OBJDUMP 1"
-.TH OBJDUMP 1 "2021-01-30" "binutils-2.35.2" "GNU Development Tools"
+.TH OBJDUMP 1 "2021-10-25" "binutils-2.35.2" "GNU Development Tools"
 .\" For nroff, turn off justification.  Always turn off hyphenation; it makes
 .\" way too many mistakes in technical documents.
 .if n .ad l
@@ -190,6 +190,7 @@ objdump [\fB\-a\fR|\fB\-\-archive\-heade
         [\fB\-\-prefix\-strip=\fR\fIlevel\fR]
         [\fB\-\-insn\-width=\fR\fIwidth\fR]
         [\fB\-\-visualize\-jumps[=color|=extended\-color|=off]\fR
+        [\fB\-U\fR \fImethod\fR] [\fB\-\-unicode=\fR\fImethod\fR]
         [\fB\-V\fR|\fB\-\-version\fR]
         [\fB\-H\fR|\fB\-\-help\fR]
         \fIobjfile\fR...
@@ -1265,6 +1266,24 @@ otherwise it's put into parentheses.
 When displaying symbols include those which the target considers to be
 special in some way and which would not normally be of interest to the
 user.
+.IP "\fB\-U\fR \fI[d|i|l|e|x|h]\fR" 4
+.IX Item "-U [d|i|l|e|x|h]"
+.PD 0
+.IP "\fB\-\-unicode=\fR\fI[default|invalid|locale|escape|hex|highlight]\fR" 4
+.IX Item "--unicode=[default|invalid|locale|escape|hex|highlight]"
+.PD
+Controls the display of \s-1UTF\-8\s0 encoded mulibyte characters in strings.
+The default (\fB\-\-unicode=default\fR) is to give them no special
+treatment.  The \fB\-\-unicode=locale\fR option displays the sequence
+in the current locale, which may or may not support them.  The options
+\&\fB\-\-unicode=hex\fR and \fB\-\-unicode=invalid\fR display them as
+hex byte sequences enclosed by either angle brackets or curly braces.
+.Sp
+The \fB\-\-unicode=escape\fR option displays them as escape sequences
+(\fI\euxxxx\fR) and the \fB\-\-unicode=highlight\fR option displays
+them as escape sequences highlighted in red (if supported by the
+output device).  The colouring is intended to draw attention to the
+presence of unicode sequences where they might not be expected.
 .IP "\fB\-V\fR" 4
 .IX Item "-V"
 .PD 0
diff -rup binutils.orig/binutils/doc/ranlib.1 binutils-2.35.2/binutils/doc/ranlib.1
--- binutils.orig/binutils/doc/ranlib.1	2021-08-16 13:07:33.366206472 +0100
+++ binutils-2.35.2/binutils/doc/ranlib.1	2021-10-25 12:13:31.289728326 +0100
@@ -1,4 +1,4 @@
-.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
+.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.42)
 .\"
 .\" Standard preamble:
 .\" ========================================================================
@@ -133,7 +133,7 @@
 .\" ========================================================================
 .\"
 .IX Title "RANLIB 1"
-.TH RANLIB 1 "2021-01-30" "binutils-2.35.2" "GNU Development Tools"
+.TH RANLIB 1 "2021-10-25" "binutils-2.35.2" "GNU Development Tools"
 .\" For nroff, turn off justification.  Always turn off hyphenation; it makes
 .\" way too many mistakes in technical documents.
 .if n .ad l
diff -rup binutils.orig/binutils/doc/readelf.1 binutils-2.35.2/binutils/doc/readelf.1
--- binutils.orig/binutils/doc/readelf.1	2021-08-16 13:07:33.367206466 +0100
+++ binutils-2.35.2/binutils/doc/readelf.1	2021-10-25 12:13:31.419727906 +0100
@@ -1,4 +1,4 @@
-.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
+.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.42)
 .\"
 .\" Standard preamble:
 .\" ========================================================================
@@ -133,7 +133,7 @@
 .\" ========================================================================
 .\"
 .IX Title "READELF 1"
-.TH READELF 1 "2021-01-30" "binutils-2.35.2" "GNU Development Tools"
+.TH READELF 1 "2021-10-25" "binutils-2.35.2" "GNU Development Tools"
 .\" For nroff, turn off justification.  Always turn off hyphenation; it makes
 .\" way too many mistakes in technical documents.
 .if n .ad l
@@ -177,6 +177,7 @@ readelf [\fB\-a\fR|\fB\-\-all\fR]
         [\fB\-W\fR|\fB\-\-wide\fR]
         [\fB\-T\fR|\fB\-\-silent\-truncation\fR]
         [\fB\-H\fR|\fB\-\-help\fR]
+        [\fB\-U\fR \fImethod\fR|\fB\-\-unicode=\fR\fImethod\fR]
         \fIelffile\fR...
 .SH "DESCRIPTION"
 .IX Header "DESCRIPTION"
@@ -274,6 +275,31 @@ displayed as a suffix preceeded by two @
 Displays the entries in dynamic symbol table section of the file, if it
 has one.  The output format is the same as the format used by the
 \&\fB\-\-syms\fR option.
+.IP "\fB\-U\fR \fI[d|i|l|e|x|h]\fR" 4
+.IX Item "-U [d|i|l|e|x|h]"
+.PD 0
+.IP "\fB\-\-unicode=[default|invalid|locale|escape|hex|highlight]\fR" 4
+.IX Item "--unicode=[default|invalid|locale|escape|hex|highlight]"
+.PD
+Controls the display of non-ASCII characters in identifier names.
+The default (\fB\-\-unicode=locale\fR or \fB\-\-unicode=default\fR) is
+to treat them as multibyte characters and display them in the current
+locale.  All other versions of this option treat the bytes as \s-1UTF\-8\s0
+encoded values and attempt to interpret them.  If they cannot be
+interpreted or if the \fB\-\-unicode=invalid\fR option is used then
+they are displayed as a sequence of hex bytes, encloses in curly
+parethesis characters.
+.Sp
+Using the \fB\-\-unicode=escape\fR option will display the characters
+as as unicode escape sequences (\fI\euxxxx\fR).  Using the
+\&\fB\-\-unicode=hex\fR will display the characters as hex byte
+sequences enclosed between angle brackets.
+.Sp
+Using the \fB\-\-unicode=highlight\fR will display the characters as 
+unicode escape sequences but it will also highlighted them in red,
+assuming that colouring is supported by the output device.  The
+colouring is intended to draw attention to the presence of unicode
+sequences when they might not be expected.
 .IP "\fB\-e\fR" 4
 .IX Item "-e"
 .PD 0
diff -rup binutils.orig/binutils/doc/size.1 binutils-2.35.2/binutils/doc/size.1
--- binutils.orig/binutils/doc/size.1	2021-08-16 13:07:33.366206472 +0100
+++ binutils-2.35.2/binutils/doc/size.1	2021-10-25 12:13:31.404727954 +0100
@@ -1,4 +1,4 @@
-.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
+.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.42)
 .\"
 .\" Standard preamble:
 .\" ========================================================================
@@ -133,7 +133,7 @@
 .\" ========================================================================
 .\"
 .IX Title "SIZE 1"
-.TH SIZE 1 "2021-01-30" "binutils-2.35.2" "GNU Development Tools"
+.TH SIZE 1 "2021-10-25" "binutils-2.35.2" "GNU Development Tools"
 .\" For nroff, turn off justification.  Always turn off hyphenation; it makes
 .\" way too many mistakes in technical documents.
 .if n .ad l
diff -rup binutils.orig/binutils/doc/strings.1 binutils-2.35.2/binutils/doc/strings.1
--- binutils.orig/binutils/doc/strings.1	2021-08-16 13:07:33.366206472 +0100
+++ binutils-2.35.2/binutils/doc/strings.1	2021-10-25 12:13:31.408727941 +0100
@@ -1,4 +1,4 @@
-.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
+.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.42)
 .\"
 .\" Standard preamble:
 .\" ========================================================================
@@ -133,7 +133,7 @@
 .\" ========================================================================
 .\"
 .IX Title "STRINGS 1"
-.TH STRINGS 1 "2021-01-30" "binutils-2.35.2" "GNU Development Tools"
+.TH STRINGS 1 "2021-10-25" "binutils-2.35.2" "GNU Development Tools"
 .\" For nroff, turn off justification.  Always turn off hyphenation; it makes
 .\" way too many mistakes in technical documents.
 .if n .ad l
@@ -146,6 +146,7 @@ strings [\fB\-afovV\fR] [\fB\-\fR\fImin-
         [\fB\-n\fR \fImin-len\fR] [\fB\-\-bytes=\fR\fImin-len\fR]
         [\fB\-t\fR \fIradix\fR] [\fB\-\-radix=\fR\fIradix\fR]
         [\fB\-e\fR \fIencoding\fR] [\fB\-\-encoding=\fR\fIencoding\fR]
+        [\fB\-U\fR \fImethod\fR] [\fB\-\-unicode=\fR\fImethod\fR]
         [\fB\-\fR] [\fB\-\-all\fR] [\fB\-\-print\-file\-name\fR]
         [\fB\-T\fR \fIbfdname\fR] [\fB\-\-target=\fR\fIbfdname\fR]
         [\fB\-w\fR] [\fB\-\-include\-all\-whitespace\fR]
@@ -250,6 +251,31 @@ single\-8\-bit\-byte characters, \fBb\fR
 16\-bit littleendian, \fBB\fR = 32\-bit bigendian, \fBL\fR = 32\-bit
 littleendian.  Useful for finding wide character strings. (\fBl\fR
 and \fBb\fR apply to, for example, Unicode \s-1UTF\-16/UCS\-2\s0 encodings).
+.IP "\fB\-U\fR \fI[d|i|l|e|x|h]\fR" 4
+.IX Item "-U [d|i|l|e|x|h]"
+.PD 0
+.IP "\fB\-\-unicode=\fR\fI[default|invalid|locale|escape|hex|highlight]\fR" 4
+.IX Item "--unicode=[default|invalid|locale|escape|hex|highlight]"
+.PD
+Controls the display of \s-1UTF\-8\s0 encoded mulibyte characters in strings.
+The default (\fB\-\-unicode=default\fR) is to give them no special
+treatment, and instead rely upon the setting of the
+\&\fB\-\-encoding\fR option.  The other values for this option
+automatically enable \fB\-\-encoding=S\fR.
+.Sp
+The \fB\-\-unicode=invalid\fR option treats them as non-graphic
+characters and hence not part of a valid string.  All the remaining
+options treat them as valid string characters.
+.Sp
+The \fB\-\-unicode=locale\fR option displays them in the current
+locale, which may or may not support \s-1UTF\-8\s0 encoding.  The
+\&\fB\-\-unicode=hex\fR option displays them as hex byte sequences
+enclosed between \fI<>\fR characters.  The \fB\-\-unicode=escape\fR
+option displays them as escape sequences (\fI\euxxxx\fR) and the
+\&\fB\-\-unicode=highlight\fR option displays them as escape sequences
+highlighted in red (if supported by the output device).  The colouring
+is intended to draw attention to the presence of unicode sequences
+where they might not be expected.
 .IP "\fB\-T\fR \fIbfdname\fR" 4
 .IX Item "-T bfdname"
 .PD 0
diff -rup binutils.orig/binutils/doc/strip.1 binutils-2.35.2/binutils/doc/strip.1
--- binutils.orig/binutils/doc/strip.1	2021-08-16 13:07:33.367206466 +0100
+++ binutils-2.35.2/binutils/doc/strip.1	2021-10-25 12:13:31.441727835 +0100
@@ -1,4 +1,4 @@
-.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
+.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.42)
 .\"
 .\" Standard preamble:
 .\" ========================================================================
@@ -133,7 +133,7 @@
 .\" ========================================================================
 .\"
 .IX Title "STRIP 1"
-.TH STRIP 1 "2021-01-30" "binutils-2.35.2" "GNU Development Tools"
+.TH STRIP 1 "2021-10-25" "binutils-2.35.2" "GNU Development Tools"
 .\" For nroff, turn off justification.  Always turn off hyphenation; it makes
 .\" way too many mistakes in technical documents.
 .if n .ad l
diff -rup binutils.orig/binutils/doc/windmc.1 binutils-2.35.2/binutils/doc/windmc.1
--- binutils.orig/binutils/doc/windmc.1	2021-08-16 13:07:33.366206472 +0100
+++ binutils-2.35.2/binutils/doc/windmc.1	2021-10-25 12:13:31.484727696 +0100
@@ -1,4 +1,4 @@
-.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
+.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.42)
 .\"
 .\" Standard preamble:
 .\" ========================================================================
@@ -133,7 +133,7 @@
 .\" ========================================================================
 .\"
 .IX Title "WINDMC 1"
-.TH WINDMC 1 "2021-01-30" "binutils-2.35.2" "GNU Development Tools"
+.TH WINDMC 1 "2021-10-25" "binutils-2.35.2" "GNU Development Tools"
 .\" For nroff, turn off justification.  Always turn off hyphenation; it makes
 .\" way too many mistakes in technical documents.
 .if n .ad l
diff -rup binutils.orig/binutils/doc/windres.1 binutils-2.35.2/binutils/doc/windres.1
--- binutils.orig/binutils/doc/windres.1	2021-08-16 13:07:33.366206472 +0100
+++ binutils-2.35.2/binutils/doc/windres.1	2021-10-25 12:13:31.467727751 +0100
@@ -1,4 +1,4 @@
-.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
+.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.42)
 .\"
 .\" Standard preamble:
 .\" ========================================================================
@@ -133,7 +133,7 @@
 .\" ========================================================================
 .\"
 .IX Title "WINDRES 1"
-.TH WINDRES 1 "2021-01-30" "binutils-2.35.2" "GNU Development Tools"
+.TH WINDRES 1 "2021-10-25" "binutils-2.35.2" "GNU Development Tools"
 .\" For nroff, turn off justification.  Always turn off hyphenation; it makes
 .\" way too many mistakes in technical documents.
 .if n .ad l
Only in binutils-2.35.2/binutils/: filemode.o
Only in binutils-2.35.2/binutils/: libtool
diff -rup binutils.orig/binutils/nm.c binutils-2.35.2/binutils/nm.c
--- binutils.orig/binutils/nm.c	2021-08-16 13:07:33.367206466 +0100
+++ binutils-2.35.2/binutils/nm.c	2021-10-25 12:12:22.313951236 +0100
@@ -38,6 +38,11 @@
 #include "bucomm.h"
 #include "plugin-api.h"
 #include "plugin.h"
+#include "safe-ctype.h"
+
+#ifndef streq
+#define streq(a,b) (strcmp ((a),(b)) == 0)
+#endif
 
 /* When sorting by size, we use this structure to hold the size and a
    pointer to the minisymbol.  */
@@ -185,6 +190,18 @@ static const char *plugin_target = NULL;
 static bfd *lineno_cache_bfd;
 static bfd *lineno_cache_rel_bfd;
 
+typedef enum unicode_display_type
+{
+  unicode_default = 0,
+  unicode_locale,
+  unicode_escape,
+  unicode_hex,
+  unicode_highlight,
+  unicode_invalid
+} unicode_display_type;
+
+static unicode_display_type unicode_display = unicode_default;
+
 enum long_option_values
 {
   OPTION_TARGET = 200,
@@ -225,6 +242,7 @@ static struct option long_options[] =
   {"target", required_argument, 0, OPTION_TARGET},
   {"defined-only", no_argument, &defined_only, 1},
   {"undefined-only", no_argument, &undefined_only, 1},
+  {"unicode", required_argument, NULL, 'U'},
   {"version", no_argument, &show_version, 1},
   {"with-symbol-versions", no_argument, NULL,
    OPTION_WITH_SYMBOL_VERSIONS},
@@ -275,6 +293,8 @@ usage (FILE *stream, int status)
   -t, --radix=RADIX      Use RADIX for printing symbol values\n\
       --target=BFDNAME   Specify the target object format as BFDNAME\n\
   -u, --undefined-only   Display only undefined symbols\n\
+  -U {d|s|i|x|e|h}       Specify how to treat UTF-8 encoded unicode characters\n\
+      --unicode={default|show|invalid|hex|escape|highlight}\n\
       --with-symbol-versions  Display version strings after symbol names\n\
   -X 32_64               (ignored)\n\
   @FILE                  Read options from FILE\n\
@@ -390,6 +410,189 @@ get_coff_symbol_type (const struct inter
   return bufp;
 }
 
+/* Convert a potential UTF-8 encoded sequence in IN into characters in OUT.
+   The conversion format is controlled by the unicode_display variable.
+   Returns the number of characters added to OUT.
+   Returns the number of bytes consumed from IN in CONSUMED.
+   Always consumes at least one byte and displays at least one character.  */
+   
+static unsigned int
+display_utf8 (const unsigned char * in, char * out, unsigned int * consumed)
+{
+  char *        orig_out = out;
+  unsigned int  nchars = 0;
+
+  if (unicode_display == unicode_default)
+    goto invalid;
+
+  if (in[0] < 0xc0)
+    goto invalid;
+
+  if ((in[1] & 0xc0) != 0x80)
+    goto invalid;
+
+  if ((in[0] & 0x20) == 0)
+    {
+      nchars = 2;
+      goto valid;
+    }
+
+  if ((in[2] & 0xc0) != 0x80)
+    goto invalid;
+
+  if ((in[0] & 0x10) == 0)
+    {
+      nchars = 3;
+      goto valid;
+    }
+
+  if ((in[3] & 0xc0) != 0x80)
+    goto invalid;
+
+  nchars = 4;
+
+ valid:
+  switch (unicode_display)
+    {
+    case unicode_locale:
+      /* Copy the bytes into the output buffer as is.  */
+      memcpy (out, in, nchars);
+      out += nchars;
+      break;
+
+    case unicode_invalid:
+    case unicode_hex:
+      {
+      unsigned int j;
+
+      out += sprintf (out, "%c", unicode_display == unicode_hex ? '<' : '{');
+      for (j = 0; j < nchars; j++)
+	out += sprintf (out, "%02x", in [j]);
+      out += sprintf (out, "%c", unicode_display == unicode_hex ? '>' : '}');
+      }
+      break;
+      
+    case unicode_highlight:
+      if (isatty (1))
+	out += sprintf (out, "\x1B[31;47m"); /* Red.  */
+      /* Fall through.  */
+    case unicode_escape:
+      switch (nchars)
+	{
+	case 2:
+	  out += sprintf (out, "\\u%02x%02x",
+		  ((in[0] & 0x1c) >> 2), 
+		  ((in[0] & 0x03) << 6) | (in[1] & 0x3f));
+	  break;
+
+	case 3:
+	  out += sprintf (out, "\\u%02x%02x",
+		  ((in[0] & 0x0f) << 4) | ((in[1] & 0x3c) >> 2),
+		  ((in[1] & 0x03) << 6) | ((in[2] & 0x3f)));
+	  break;
+
+	case 4:
+	  out += sprintf (out, "\\u%02x%02x%02x",
+		  ((in[0] & 0x07) << 6) | ((in[1] & 0x3c) >> 2),
+		  ((in[1] & 0x03) << 6) | ((in[2] & 0x3c) >> 2),
+		  ((in[2] & 0x03) << 6) | ((in[3] & 0x3f)));
+	  break;
+	default:
+	  /* URG.  */
+	  break;
+	}
+
+      if (unicode_display == unicode_highlight && isatty (1))
+	out += sprintf (out, "\033[0m"); /* Default colour.  */
+      break;
+
+    default:
+      /* URG */
+      break;
+    }
+
+  * consumed = nchars;
+  return out - orig_out;
+
+ invalid:
+  /* Not a valid UTF-8 sequence.  */
+  *out = *in;
+  * consumed = 1;
+  return 1;
+}
+
+/* Convert any UTF-8 encoded characters in NAME into the form specified by
+   unicode_display.  Also converts control characters.  Returns a static
+   buffer if conversion was necessary.
+   Code stolen from objdump.c:sanitize_string().  */
+
+static const char *
+convert_utf8 (const char * in)
+{
+  static char *  buffer = NULL;
+  static size_t  buffer_len = 0;
+  const char *   original = in;
+  char *         out;
+
+  /* Paranoia.  */
+  if (in == NULL)
+    return "";
+
+  /* See if any conversion is necessary.
+     In the majority of cases it will not be needed.  */
+  do
+    {
+      unsigned char c = *in++;
+
+      if (c == 0)
+	return original;
+
+      if (ISCNTRL (c))
+	break;
+
+      if (unicode_display != unicode_default && c >= 0xc0)
+	break;
+    }
+  while (1);
+
+  /* Copy the input, translating as needed.  */
+  in = original;
+  if (buffer_len < (strlen (in) * 9))
+    {
+      free ((void *) buffer);
+      buffer_len = strlen (in) * 9;
+      buffer = xmalloc (buffer_len + 1);
+    }
+
+  out = buffer;
+  do
+    {
+      unsigned char c = *in++;
+
+      if (c == 0)
+	break;
+
+      if (ISCNTRL (c))
+	{
+	  *out++ = '^';
+	  *out++ = c + 0x40;
+	}
+      else if (unicode_display != unicode_default && c >= 0xc0)
+	{
+	  unsigned int num_consumed;
+
+	  out += display_utf8 ((const unsigned char *)(in - 1), out, & num_consumed);
+	  in += num_consumed - 1;
+	}
+      else
+	*out++ = c;
+    }
+  while (1);
+
+  *out = 0;
+  return buffer;
+}
+
 /* Print symbol name NAME, read from ABFD, with printf format FORM,
    demangling it if requested.  */
 
@@ -408,6 +611,9 @@ print_symname (const char *form, struct
 	name = alloc;
     }
 
+  if (unicode_display != unicode_default)
+    name = convert_utf8 (name);
+
   if (info != NULL && info->elfinfo)
     {
       const char *version_string;
@@ -1716,7 +1922,7 @@ main (int argc, char **argv)
     fatal (_("fatal error: libbfd ABI mismatch"));
   set_default_bfd_target ();
 
-  while ((c = getopt_long (argc, argv, "aABCDef:gHhlnopPrSst:uvVvX:",
+  while ((c = getopt_long (argc, argv, "aABCDef:gHhlnopPrSst:uU:vVvX:",
 			   long_options, (int *) 0)) != EOF)
     {
       switch (c)
@@ -1806,6 +2012,24 @@ main (int argc, char **argv)
 	case 'u':
 	  undefined_only = 1;
 	  break;
+
+	case 'U':
+	  if (streq (optarg, "default") || streq (optarg, "d"))
+	    unicode_display = unicode_default;
+	  else if (streq (optarg, "locale") || streq (optarg, "l"))
+	    unicode_display = unicode_locale;
+	  else if (streq (optarg, "escape") || streq (optarg, "e"))
+	    unicode_display = unicode_escape;
+	  else if (streq (optarg, "invalid") || streq (optarg, "i"))
+	    unicode_display = unicode_invalid;
+	  else if (streq (optarg, "hex") || streq (optarg, "x"))
+	    unicode_display = unicode_hex;
+	  else if (streq (optarg, "highlight") || streq (optarg, "h"))
+	    unicode_display = unicode_highlight;
+	  else
+	    fatal (_("invalid argument to -U/--unicode: %s"), optarg);
+	  break;
+
 	case 'V':
 	  show_version = 1;
 	  break;
diff -rup binutils.orig/binutils/objdump.c binutils-2.35.2/binutils/objdump.c
--- binutils.orig/binutils/objdump.c	2021-08-16 13:07:33.368206459 +0100
+++ binutils-2.35.2/binutils/objdump.c	2021-10-25 12:16:10.140214947 +0100
@@ -205,6 +205,18 @@ static const struct objdump_private_desc
 
 /* The list of detected jumps inside a function.  */
 static struct jump_info *detected_jumps = NULL;
+
+typedef enum unicode_display_type
+{
+  unicode_default = 0,
+  unicode_locale,
+  unicode_escape,
+  unicode_hex,
+  unicode_highlight,
+  unicode_invalid
+} unicode_display_type;
+
+static unicode_display_type unicode_display = unicode_default;
 
 static void usage (FILE *, int) ATTRIBUTE_NORETURN;
 static void
@@ -247,6 +259,9 @@ usage (FILE *stream, int status)
   -r, --reloc              Display the relocation entries in the file\n\
   -R, --dynamic-reloc      Display the dynamic relocation entries in the file\n\
   @<file>                  Read options from <file>\n\
+  -U[d|l|i|x|e|h]          Controls the display of UTF-8 unicode characters\n\
+  --unicode=[default|locale|invalid|hex|escape|highlight]\n"));
+      fprintf (stream, _("\
   -v, --version            Display this program's version number\n\
   -i, --info               List object formats and architectures supported\n\
   -H, --help               Display this information\n\
@@ -395,6 +410,7 @@ static struct option long_options[]=
   {"stop-address", required_argument, NULL, OPTION_STOP_ADDRESS},
   {"syms", no_argument, NULL, 't'},
   {"target", required_argument, NULL, 'b'},
+  {"unicode", required_argument, NULL, 'U'},
   {"version", no_argument, NULL, 'V'},
   {"wide", no_argument, NULL, 'w'},
   {"prefix", required_argument, NULL, OPTION_PREFIX},
@@ -415,9 +431,123 @@ nonfatal (const char *msg)
   exit_status = 1;
 }
 
+/* Convert a potential UTF-8 encoded sequence in IN into characters in OUT.
+   The conversion format is controlled by the unicode_display variable.
+   Returns the number of characters added to OUT.
+   Returns the number of bytes consumed from IN in CONSUMED.
+   Always consumes at least one byte and displays at least one character.  */
+   
+static unsigned int
+display_utf8 (const unsigned char * in, char * out, unsigned int * consumed)
+{
+  char *        orig_out = out;
+  unsigned int  nchars = 0;
+
+  if (unicode_display == unicode_default)
+    goto invalid;
+
+  if (in[0] < 0xc0)
+    goto invalid;
+
+  if ((in[1] & 0xc0) != 0x80)
+    goto invalid;
+
+  if ((in[0] & 0x20) == 0)
+    {
+      nchars = 2;
+      goto valid;
+    }
+
+  if ((in[2] & 0xc0) != 0x80)
+    goto invalid;
+
+  if ((in[0] & 0x10) == 0)
+    {
+      nchars = 3;
+      goto valid;
+    }
+
+  if ((in[3] & 0xc0) != 0x80)
+    goto invalid;
+
+  nchars = 4;
+
+ valid:
+  switch (unicode_display)
+    {
+    case unicode_locale:
+      /* Copy the bytes into the output buffer as is.  */
+      memcpy (out, in, nchars);
+      out += nchars;
+      break;
+
+    case unicode_invalid:
+    case unicode_hex:
+      {
+      unsigned int j;
+
+      out += sprintf (out, "%c", unicode_display == unicode_hex ? '<' : '{');
+      for (j = 0; j < nchars; j++)
+	out += sprintf (out, "%02x", in [j]);
+      out += sprintf (out, "%c", unicode_display == unicode_hex ? '>' : '}');
+      }
+      break;
+      
+    case unicode_highlight:
+      if (isatty (1))
+	out += sprintf (out, "\x1B[31;47m"); /* Red.  */
+      /* Fall through.  */
+    case unicode_escape:
+      switch (nchars)
+	{
+	case 2:
+	  out += sprintf (out, "\\u%02x%02x",
+		  ((in[0] & 0x1c) >> 2), 
+		  ((in[0] & 0x03) << 6) | (in[1] & 0x3f));
+	  break;
+
+	case 3:
+	  out += sprintf (out, "\\u%02x%02x",
+		  ((in[0] & 0x0f) << 4) | ((in[1] & 0x3c) >> 2),
+		  ((in[1] & 0x03) << 6) | ((in[2] & 0x3f)));
+	  break;
+
+	case 4:
+	  out += sprintf (out, "\\u%02x%02x%02x",
+		  ((in[0] & 0x07) << 6) | ((in[1] & 0x3c) >> 2),
+		  ((in[1] & 0x03) << 6) | ((in[2] & 0x3c) >> 2),
+		  ((in[2] & 0x03) << 6) | ((in[3] & 0x3f)));
+	  break;
+	default:
+	  /* URG.  */
+	  break;
+	}
+
+      if (unicode_display == unicode_highlight && isatty (1))
+	out += sprintf (out, "\033[0m"); /* Default colour.  */
+      break;
+
+    default:
+      /* URG */
+      break;
+    }
+
+  * consumed = nchars;
+  return out - orig_out;
+
+ invalid:
+  /* Not a valid UTF-8 sequence.  */
+  *out = *in;
+  * consumed = 1;
+  return 1;
+}
+
 /* Returns a version of IN with any control characters
    replaced by escape sequences.  Uses a static buffer
-   if necessary.  */
+   if necessary.
+
+   If unicode display is enabled, then also handles the
+   conversion of unicode characters.  */
 
 static const char *
 sanitize_string (const char * in)
@@ -435,40 +565,50 @@ sanitize_string (const char * in)
      of cases it will not be needed.  */
   do
     {
-      char c = *in++;
+      unsigned char c = *in++;
 
       if (c == 0)
 	return original;
 
       if (ISCNTRL (c))
 	break;
+
+      if (unicode_display != unicode_default && c >= 0xc0)
+	break;
     }
   while (1);
 
   /* Copy the input, translating as needed.  */
   in = original;
-  if (buffer_len < (strlen (in) * 2))
+  if (buffer_len < (strlen (in) * 9))
     {
       free ((void *) buffer);
-      buffer_len = strlen (in) * 2;
+      buffer_len = strlen (in) * 9;
       buffer = xmalloc (buffer_len + 1);
     }
 
   out = buffer;
   do
     {
-      char c = *in++;
+      unsigned char c = *in++;
 
       if (c == 0)
 	break;
 
-      if (!ISCNTRL (c))
-	*out++ = c;
-      else
+      if (ISCNTRL (c))
 	{
 	  *out++ = '^';
 	  *out++ = c + 0x40;
 	}
+      else if (unicode_display != unicode_default && c >= 0xc0)
+	{
+	  unsigned int num_consumed;
+
+	  out += display_utf8 ((const unsigned char *)(in - 1), out, & num_consumed);
+	  in += num_consumed - 1;
+	}
+      else
+	*out++ = c;
     }
   while (1);
 
@@ -476,7 +616,6 @@ sanitize_string (const char * in)
   return buffer;
 }
 
-
 /* Returns TRUE if the specified section should be dumped.  */
 
 static bfd_boolean
@@ -1055,6 +1194,8 @@ objdump_print_symname (bfd *abfd, struct
 
   name = sanitize_string (name);
 
+  name = sanitize_string (name);
+
   if (inf != NULL)
     {
       (*inf->fprintf_func) (inf->stream, "%s", name);
@@ -3136,7 +3277,7 @@ disassemble_section (bfd *abfd, asection
   if (!bfd_malloc_and_get_section (abfd, section, &data))
     {
       non_fatal (_("Reading section %s failed because: %s"),
-		 section->name, bfd_errmsg (bfd_get_error ()));
+		 sanitize_string (section->name), bfd_errmsg (bfd_get_error ()));
       return;
     }
 
@@ -4307,7 +4448,7 @@ dump_section (bfd *abfd, asection *secti
   if (!bfd_get_full_section_contents (abfd, section, &data))
     {
       non_fatal (_("Reading section %s failed because: %s"),
-		 section->name, bfd_errmsg (bfd_get_error ()));
+		 sanitize_string (section->name), bfd_errmsg (bfd_get_error ()));
       return;
     }
 
@@ -4447,6 +4588,24 @@ dump_symbols (bfd *abfd ATTRIBUTE_UNUSED
 		  free (alloc);
 		}
 	    }
+	  else if (unicode_display != unicode_default
+		   && name != NULL && *name != '\0')
+	    {
+	      const char * sanitized_name;
+
+	      /* If we want to sanitize the name, we do it here, and
+		 temporarily clobber it while calling bfd_print_symbol.
+		 FIXME: This is a gross hack.  */
+	      sanitized_name = sanitize_string (name);
+	      if (sanitized_name != name)
+		(*current)->name = sanitized_name;
+	      else
+		sanitized_name = NULL;
+	      bfd_print_symbol (cur_bfd, stdout, *current,
+				bfd_print_symbol_all);
+	      if (sanitized_name != NULL)
+		(*current)->name = name;
+	    }
 	  else
 	    bfd_print_symbol (cur_bfd, stdout, *current,
 			      bfd_print_symbol_all);
@@ -5128,7 +5287,7 @@ main (int argc, char **argv)
   set_default_bfd_target ();
 
   while ((c = getopt_long (argc, argv,
-			   "pP:ib:m:M:VvCdDlfFaHhrRtTxsSI:j:wE:zgeGW::",
+			   "pP:ib:m:M:VvCdDlfFaHhrRtTxsSI:j:wE:zgeGW::U:",
 			   long_options, (int *) 0))
 	 != EOF)
     {
@@ -5407,6 +5566,23 @@ main (int argc, char **argv)
 	  seenflag = TRUE;
 	  break;
 
+	case 'U':
+	  if (streq (optarg, "default") || streq (optarg, "d"))
+	    unicode_display = unicode_default;
+	  else if (streq (optarg, "locale") || streq (optarg, "l"))
+	    unicode_display = unicode_locale;
+	  else if (streq (optarg, "escape") || streq (optarg, "e"))
+	    unicode_display = unicode_escape;
+	  else if (streq (optarg, "invalid") || streq (optarg, "i"))
+	    unicode_display = unicode_invalid;
+	  else if (streq (optarg, "hex") || streq (optarg, "x"))
+	    unicode_display = unicode_hex;
+	  else if (streq (optarg, "highlight") || streq (optarg, "h"))
+	    unicode_display = unicode_highlight;
+	  else
+	    fatal (_("invalid argument to -U/--unicode: %s"), optarg);
+	  break;
+
 	case 'H':
 	  usage (stdout, 0);
 	  /* No need to set seenflag or to break - usage() does not return.  */
Only in binutils-2.35.2/binutils/po: Makefile
Only in binutils-2.35.2/binutils/po: Makefile.in
Only in binutils-2.35.2/binutils/po: POTFILES
diff -rup binutils.orig/binutils/readelf.c binutils-2.35.2/binutils/readelf.c
--- binutils.orig/binutils/readelf.c	2021-08-16 13:07:33.384206359 +0100
+++ binutils-2.35.2/binutils/readelf.c	2021-10-25 12:12:22.318951219 +0100
@@ -317,6 +317,18 @@ typedef enum print_mode
 }
 print_mode;
 
+typedef enum unicode_display_type
+{
+  unicode_locale,
+  unicode_escape,
+  unicode_hex,
+  unicode_highlight,
+  unicode_invalid
+} unicode_display_type;
+
+static unicode_display_type unicode_display = unicode_locale;
+
+  
 /* Versioned symbol info.  */
 enum versioned_symbol_info
 {
@@ -592,11 +604,18 @@ print_symbol (signed int width, const ch
       if (c == 0)
 	break;
 
-      /* Do not print control characters directly as they can affect terminal
-	 settings.  Such characters usually appear in the names generated
-	 by the assembler for local labels.  */
-      if (ISCNTRL (c))
+      if (ISPRINT (c))
+	{
+	  putchar (c);
+	  width_remaining --;
+	  num_printed ++;
+	}
+      else if (ISCNTRL (c))
 	{
+	  /* Do not print control characters directly as they can affect terminal
+	     settings.  Such characters usually appear in the names generated
+	     by the assembler for local labels.  */
+
 	  if (width_remaining < 2)
 	    break;
 
@@ -604,11 +623,135 @@ print_symbol (signed int width, const ch
 	  width_remaining -= 2;
 	  num_printed += 2;
 	}
-      else if (ISPRINT (c))
+      else if (c == 0x7f)
 	{
-	  putchar (c);
-	  width_remaining --;
-	  num_printed ++;
+	  if (width_remaining < 5)
+	    break;
+	  printf ("<DEL>");
+	  width_remaining -= 5;
+	  num_printed += 5;
+	}
+      else if (unicode_display != unicode_locale)
+	{
+	  /* Display unicode characters as something else.  */
+	  unsigned char bytes[4];
+	  bfd_boolean   is_utf8;
+	  unsigned int  nbytes;
+
+	  bytes[0] = c;
+
+	  if (bytes[0] < 0xc0)
+	    {
+	      nbytes = 1;
+	      is_utf8 = FALSE;
+	    }
+	  else
+	    {
+	      bytes[1] = *symbol++;
+
+	      if ((bytes[1] & 0xc0) != 0x80)
+		{
+		  is_utf8 = FALSE;
+		  /* Do not consume this character.  It may only
+		     be the first byte in the sequence that was
+		     corrupt.  */
+		  --symbol;
+		  nbytes = 1;
+		}
+	      else if ((bytes[0] & 0x20) == 0)
+		{
+		  is_utf8 = TRUE;
+		  nbytes = 2;
+		}
+	      else
+		{
+		  bytes[2] = *symbol++;
+
+		  if ((bytes[2] & 0xc0) != 0x80)
+		    {
+		      is_utf8 = FALSE;
+		      symbol -= 2;
+		      nbytes = 1;
+		    }
+		  else if ((bytes[0] & 0x10) == 0)
+		    {
+		      is_utf8 = TRUE;
+		      nbytes = 3;
+		    }
+		  else
+		    {
+		      bytes[3] = *symbol++;
+
+		      nbytes = 4;
+
+		      if ((bytes[3] & 0xc0) != 0x80)
+			{
+			  is_utf8 = FALSE;
+			  symbol -= 3;
+			  nbytes = 1;
+			}
+		      else
+			is_utf8 = TRUE;
+		    }
+		}
+	    }
+
+	  if (unicode_display == unicode_invalid)
+	    is_utf8 = FALSE;
+
+	  if (unicode_display == unicode_hex || ! is_utf8)
+	    {
+	      unsigned int i;
+
+	      if (width_remaining < (nbytes * 2) + 2)
+		break;
+	  
+	      putchar (is_utf8 ? '<' : '{');
+	      for (i = 0; i < nbytes; i++)
+		printf ("%02x", bytes[i]);
+	      putchar (is_utf8 ? '>' : '}');
+	    }
+	  else
+	    {
+	      if (unicode_display == unicode_highlight && isatty (1))
+		printf ("\x1B[31;47m"); /* Red.  */
+	      
+	      switch (nbytes)
+		{
+		case 2:
+		  if (width_remaining < 6)
+		    break;
+		  printf ("\\u%02x%02x",
+			  (bytes[0] & 0x1c) >> 2, 
+			  ((bytes[0] & 0x03) << 6) | (bytes[1] & 0x3f));
+		  break;
+		case 3:
+		  if (width_remaining < 6)
+		    break;
+		  printf ("\\u%02x%02x",
+			  ((bytes[0] & 0x0f) << 4) | ((bytes[1] & 0x3c) >> 2),
+			  ((bytes[1] & 0x03) << 6) | (bytes[2] & 0x3f));
+		  break;
+		case 4:
+		  if (width_remaining < 8)
+		    break;
+		  printf ("\\u%02x%02x%02x",
+			  ((bytes[0] & 0x07) << 6) | ((bytes[1] & 0x3c) >> 2),
+			  ((bytes[1] & 0x03) << 6) | ((bytes[2] & 0x3c) >> 2),
+			  ((bytes[2] & 0x03) << 6) | (bytes[3] & 0x3f));
+		  
+		  break;
+		default:
+		  /* URG.  */
+		  break;
+		}
+
+	      if (unicode_display == unicode_highlight && isatty (1))
+		printf ("\033[0m"); /* Default colour.  */
+	    }
+	  
+	  if (bytes[nbytes - 1] == 0)
+	    break;
 	}
       else
 	{
@@ -4528,6 +4671,7 @@ static struct option options[] =
   {"ctf-parent",       required_argument, 0, OPTION_CTF_PARENT},
 #endif
 
+  {"unicode",          required_argument, 0, 'U'},
   {"version",	       no_argument, 0, 'v'},
   {"wide",	       no_argument, 0, 'W'},
   {"silent-truncation",no_argument, 0, 'T'},
@@ -4599,6 +4743,11 @@ usage (FILE * stream)
   -I --histogram         Display histogram of bucket list lengths\n\
   -W --wide              Allow output width to exceed 80 characters\n\
   -T --silent-truncation If a symbol name is truncated, do not add a suffix [...]\n\
+  -U --unicode=[locale|escape|hex|highlight|invalid]\n\
+                         Display unicode characters as determined by the current locale\n\
+                          (default), escape sequences, \"<hex sequences>\", highlighted\n\
+                          escape sequences, or treat them as invalid and display as\n\
+                          \"{hex sequences}\"\n\
   @<file>                Read options from <file>\n\
   -H --help              Display this information\n\
   -v --version           Display the version number of readelf\n"));
@@ -4693,7 +4842,7 @@ parse_args (struct dump_data *dumpdata,
     usage (stderr);
 
   while ((c = getopt_long
-	  (argc, argv, "ADHILNR:STVWacdeghi:lnp:rstuvw::x:z", options, NULL)) != EOF)
+	  (argc, argv, "ADHILNR:STU:VWacdeghi:lnp:rstuvw::x:z", options, NULL)) != EOF)
     {
       switch (c)
 	{
@@ -4843,6 +4992,25 @@ parse_args (struct dump_data *dumpdata,
 	  request_dump (dumpdata, DISASS_DUMP);
 	  break;
 #endif
+	case 'U':
+	  if (optarg == NULL)
+	    error (_("Missing arg to -U/--unicode")); /* Can this happen ?  */
+	  else if (streq (optarg, "default") || streq (optarg, "d"))
+	    unicode_display = unicode_locale;
+	  else if (streq (optarg, "locale") || streq (optarg, "l"))
+	    unicode_display = unicode_locale;
+	  else if (streq (optarg, "escape") || streq (optarg, "e"))
+	    unicode_display = unicode_escape;
+	  else if (streq (optarg, "invalid") || streq (optarg, "i"))
+	    unicode_display = unicode_invalid;
+	  else if (streq (optarg, "hex") || streq (optarg, "x"))
+	    unicode_display = unicode_hex;
+	  else if (streq (optarg, "highlight") || streq (optarg, "h"))
+	    unicode_display = unicode_highlight;
+	  else
+	    error (_("unknown argument to -U/--unicode: %s"), optarg);
+	  break;
+
 	case 'v':
 	  print_version (program_name);
 	  break;
Only in binutils-2.35.2/binutils/: size.o
Only in binutils-2.35.2/binutils/: stamp-h1
diff -rup binutils.orig/binutils/strings.c binutils-2.35.2/binutils/strings.c
--- binutils.orig/binutils/strings.c	2021-08-16 13:07:33.382206371 +0100
+++ binutils-2.35.2/binutils/strings.c	2021-10-25 12:12:22.319951216 +0100
@@ -55,6 +55,19 @@
    -T {bfdname}
 		Specify a non-default object file format.
 
+  --unicode={default|locale|invalid|hex|escape|highlight}
+  -U {d|l|i|x|e|h}
+                Determine how to handle UTF-8 unicode characters.  The default
+		is no special treatment.  All other versions of this option
+		only apply if the encoding is valid and enabling the option
+		implies --encoding=S.
+		The 'locale' option displays the characters according to the
+		current locale.  The 'invalid' option treats them as
+		non-string characters.  The 'hex' option displays them as hex
+		byte sequences.  The 'escape' option displays them as escape
+		sequences and the 'highlight' option displays them as
+		coloured escape sequences.
+
   --output-separator=sep_string
   -s sep_string	String used to separate parsed strings in output.
 		Default is newline.
@@ -76,6 +89,22 @@
 #include "safe-ctype.h"
 #include "bucomm.h"
 
+#ifndef streq
+#define streq(a,b) (strcmp ((a),(b)) == 0)
+#endif
+
+typedef enum unicode_display_type
+{
+  unicode_default = 0,
+  unicode_locale,
+  unicode_escape,
+  unicode_hex,
+  unicode_highlight,
+  unicode_invalid
+} unicode_display_type;
+
+static unicode_display_type unicode_display = unicode_default;
+
 #define STRING_ISGRAPHIC(c) \
       (   (c) >= 0 \
        && (c) <= 255 \
@@ -94,7 +123,7 @@ extern int errno;
 static int address_radix;
 
 /* Minimum length of sequence of graphic chars to trigger output.  */
-static int string_min;
+static uint string_min;
 
 /* Whether or not we include all whitespace as a graphic char.   */
 static bfd_boolean include_all_whitespace;
@@ -130,6 +159,7 @@ static struct option long_options[] =
   {"target", required_argument, NULL, 'T'},
   {"output-separator", required_argument, NULL, 's'},
   {"help", no_argument, NULL, 'h'},
+  {"unicode", required_argument, NULL, 'U'},
   {"version", no_argument, NULL, 'v'},
   {NULL, 0, NULL, 0}
 };
@@ -173,7 +203,7 @@ main (int argc, char **argv)
   encoding = 's';
   output_separator = NULL;
 
-  while ((optc = getopt_long (argc, argv, "adfhHn:wot:e:T:s:Vv0123456789",
+  while ((optc = getopt_long (argc, argv, "adfhHn:wot:e:T:s:U:Vv0123456789",
 			      long_options, (int *) 0)) != EOF)
     {
       switch (optc)
@@ -246,6 +276,23 @@ main (int argc, char **argv)
 	  output_separator = optarg;
           break;
 
+	case 'U':
+	  if (streq (optarg, "default") || streq (optarg, "d"))
+	    unicode_display = unicode_default;
+	  else if (streq (optarg, "locale") || streq (optarg, "l"))
+	    unicode_display = unicode_locale;
+	  else if (streq (optarg, "escape") || streq (optarg, "e"))
+	    unicode_display = unicode_escape;
+	  else if (streq (optarg, "invalid") || streq (optarg, "i"))
+	    unicode_display = unicode_invalid;
+	  else if (streq (optarg, "hex") || streq (optarg, "x"))
+	    unicode_display = unicode_hex;
+	  else if (streq (optarg, "highlight") || streq (optarg, "h"))
+	    unicode_display = unicode_highlight;
+	  else
+	    fatal (_("invalid argument to -U/--unicode: %s"), optarg);
+	  break;
+
 	case 'V':
 	case 'v':
 	  print_version ("strings");
@@ -260,6 +307,9 @@ main (int argc, char **argv)
 	}
     }
 
+  if (unicode_display != unicode_default)
+    encoding = 'S';
+
   if (numeric_opt != 0)
     {
       string_min = (int) strtoul (argv[numeric_opt - 1] + 1, &s, 0);
@@ -553,11 +603,629 @@ unget_part_char (long c, file_ptr *addre
 	}
     }
 }
+
+static void
+print_filename_and_address (const char * filename, file_ptr address)
+{
+  if (print_filenames)
+    printf ("%s: ", filename);
+
+  if (! print_addresses)
+    return;
+
+  switch (address_radix)
+    {
+    case 8:
+      if (sizeof (address) > sizeof (long))
+	{
+#ifndef __MSVCRT__
+	  printf ("%7llo ", (unsigned long long) address);
+#else
+	  printf ("%7I64o ", (unsigned long long) address);
+#endif
+	}
+      else
+	printf ("%7lo ", (unsigned long) address);
+      break;
+
+    case 10:
+      if (sizeof (address) > sizeof (long))
+	{
+#ifndef __MSVCRT__
+	  printf ("%7llu ", (unsigned long long) address);
+#else
+	  printf ("%7I64d ", (unsigned long long) address);
+#endif
+	}
+      else
+	printf ("%7ld ", (long) address);
+      break;
+
+    case 16:
+      if (sizeof (address) > sizeof (long))
+	{
+#ifndef __MSVCRT__
+	  printf ("%7llx ", (unsigned long long) address);
+#else
+	  printf ("%7I64x ", (unsigned long long) address);
+#endif
+	}
+      else
+	printf ("%7lx ", (unsigned long) address);
+      break;
+    }
+}
+
+/* Return non-zero if the bytes starting at BUFFER form a valid UTF-8 encoding.
+   If the encoding is valid then returns the number of bytes it uses.  */
+
+static unsigned int
+is_valid_utf8 (const unsigned char * buffer, unsigned long buflen)
+{
+  if (buffer[0] < 0xc0)
+    return 0;
+
+  if (buflen < 2)
+    return 0;
+
+  if ((buffer[1] & 0xc0) != 0x80)
+    return 0;
+
+  if ((buffer[0] & 0x20) == 0)
+    return 2;
+
+  if (buflen < 3)
+    return 0;
+
+  if ((buffer[2] & 0xc0) != 0x80)
+    return 0;
+  
+  if ((buffer[0] & 0x10) == 0)
+    return 3;
+
+  if (buflen < 4)
+    return 0;
+
+  if ((buffer[3] & 0xc0) != 0x80)
+    return 0;
+
+  return 4;
+}
+
+/* Display a UTF-8 encoded character in BUFFER according to the setting
+   of unicode_display.  The character is known to be valid.
+   Returns the number of bytes consumed.  */
+
+static unsigned int
+display_utf8_char (const unsigned char * buffer)
+{
+  unsigned int j;
+  unsigned int utf8_len;
+
+  switch (buffer[0] & 0x30)
+    {
+    case 0x00:
+    case 0x10:
+      utf8_len = 2;
+      break;
+    case 0x20:
+      utf8_len = 3;
+      break;
+    default:
+      utf8_len = 4;
+    }
+      
+  switch (unicode_display)
+    {
+    default:
+      fprintf (stderr, "ICE: unexpected unicode display type\n");
+      break;
+
+    case unicode_escape:
+    case unicode_highlight:
+      if (unicode_display == unicode_highlight && isatty (1))
+	printf ("\x1B[31;47m"); /* Red.  */
+
+      switch (utf8_len)
+	{
+	case 2:
+	  printf ("\\u%02x%02x",
+		  ((buffer[0] & 0x1c) >> 2), 
+		  ((buffer[0] & 0x03) << 6) | (buffer[1] & 0x3f));
+	  break;
+
+	case 3:
+	  printf ("\\u%02x%02x",
+		  ((buffer[0] & 0x0f) << 4) | ((buffer[1] & 0x3c) >> 2),
+		  ((buffer[1] & 0x03) << 6) | ((buffer[2] & 0x3f)));
+	  break;
+
+	case 4:
+	  printf ("\\u%02x%02x%02x",
+		  ((buffer[0] & 0x07) << 6) | ((buffer[1] & 0x3c) >> 2),
+		  ((buffer[1] & 0x03) << 6) | ((buffer[2] & 0x3c) >> 2),
+		  ((buffer[2] & 0x03) << 6) | ((buffer[3] & 0x3f)));
+	  break;
+	default:
+	  /* URG.  */
+	  break;
+	}
+
+      if (unicode_display == unicode_highlight && isatty (1))
+	printf ("\033[0m"); /* Default colour.  */
+      break;
+
+    case unicode_hex:
+      putchar ('<');
+      for (j = 0; j < utf8_len; j++)
+	printf ("%02x", buffer [j]);
+      putchar ('>');
+      break;
+
+    case unicode_locale:
+      printf ("%.1s", buffer);
+      break;
+    }
+
+  return utf8_len;
+}
+
+/* Display strings in BUFFER.  Treat any UTF-8 encoded characters encountered
+   according to the setting of the unicode_display variable.  The buffer
+   contains BUFLEN bytes.
+
+   Display the characters as if they started at ADDRESS and are contained in
+   FILENAME.  */
+
+static void
+print_unicode_buffer (const char *            filename,
+		      file_ptr                address,
+		      const unsigned char *   buffer,
+		      unsigned long           buflen)
+{
+  /* Paranoia checks...  */
+  if (filename == NULL
+      || buffer == NULL
+      || unicode_display == unicode_default
+      || encoding != 'S'
+      || encoding_bytes != 1)
+    {
+      fprintf (stderr, "ICE: bad arguments to print_unicode_buffer\n");
+      return;
+    }
+
+  if (buflen == 0)
+    return;
+
+  /* We must only display strings that are at least string_min *characters*
+     long.  So we scan the buffer in two stages.  First we locate the start
+     of a potential string.  Then we walk along it until we have found
+     string_min characters.  Then we go back to the start point and start
+     displaying characters according to the unicode_display setting.  */
+
+  unsigned long start_point = 0;
+  unsigned long i = 0;
+  unsigned int char_len = 1;
+  unsigned int num_found = 0;
+
+  for (i = 0; i < buflen; i += char_len)
+    {
+      int c = buffer[i];
+
+      char_len = 1;
+
+      /* Find the first potential character of a string.  */
+      if (! STRING_ISGRAPHIC (c))
+	{
+	  num_found = 0;
+	  continue;
+	}
+
+      if (c > 126)
+	{
+	  if (c < 0xc0)
+	    {
+	      num_found = 0;
+	      continue;
+	    }
+
+	  if ((char_len = is_valid_utf8 (buffer + i, buflen - i)) == 0)
+	    {
+	      char_len = 1;
+	      num_found = 0;
+	      continue;
+	    }
+
+	  if (unicode_display == unicode_invalid)
+	    {
+	      /* We have found a valid UTF-8 character, but we treat it as non-graphic.  */
+	      num_found = 0;
+	      continue;
+	    }
+	}
+
+      if (num_found == 0)
+	/* We have found a potential starting point for a string.  */
+	start_point = i;
+
+      ++ num_found;
+
+      if (num_found >= string_min)
+	break;
+    }
+
+  if (num_found < string_min)
+    return;
+
+  print_filename_and_address (filename, address + start_point);
+  
+  /* We have found string_min characters.  Display them and any
+     more that follow.  */
+  for (i = start_point; i < buflen; i += char_len)
+    {
+      int c = buffer[i];
+
+      char_len = 1;
+
+      if (! STRING_ISGRAPHIC (c))
+	break;
+      else if (c < 127)
+	putchar (c);
+      else if (! is_valid_utf8 (buffer + i, buflen - i))
+	break;
+      else if (unicode_display == unicode_invalid)
+	break;
+      else
+	char_len = display_utf8_char (buffer + i);
+    }
+
+  if (output_separator)
+    fputs (output_separator, stdout);
+  else
+    putchar ('\n');
+
+  /* FIXME: Using tail recursion here is lazy programming...  */
+  print_unicode_buffer (filename, address + i, buffer + i, buflen - i);
+}
+
+static int
+get_unicode_byte (FILE *           stream,
+		  unsigned char *  putback,
+		  unsigned int *   num_putback,
+		  unsigned int *   num_read)
+{
+  if (* num_putback > 0)
+    {
+      * num_putback = * num_putback - 1;
+      return putback [* num_putback];
+    }
+
+  * num_read = * num_read + 1;
+
+#if defined(HAVE_GETC_UNLOCKED) && HAVE_DECL_GETC_UNLOCKED
+  return getc_unlocked (stream);
+#else
+  return getc (stream);
+#endif
+}
+
+/* Helper function for print_unicode_stream.  */
+
+static void
+print_unicode_stream_body (const char *     filename,
+			   file_ptr         address,
+			   FILE *           stream,
+			   unsigned char *  putback_buf,
+			   unsigned int     num_putback,
+			   unsigned char *  print_buf)
+{
+  /* It would be nice if we could just read the stream into a buffer
+     and then process if with print_unicode_buffer.  But the input
+     might be huge or it might time-locked (eg stdin).  So instead
+     we go one byte at a time...  */
+
+  file_ptr start_point = 0;
+  unsigned int num_read = 0;
+  unsigned int num_chars = 0;
+  unsigned int num_print = 0;
+  int c;
+
+  /* Find a series of string_min characters.  Put them into print_buf.  */
+  do
+    {
+      if (num_chars >= string_min)
+	break;
+
+      c = get_unicode_byte (stream, putback_buf, & num_putback, & num_read);
+      if (c == EOF)
+	break;
+
+      if (! STRING_ISGRAPHIC (c))
+	{
+	  num_chars = num_print = 0;
+	  continue;
+	}
+
+      if (num_chars == 0)
+	start_point = num_read - 1;
+
+      if (c < 127)
+	{
+	  print_buf[num_print] = c;
+	  num_chars ++;
+	  num_print ++;
+	  continue;
+	}
+
+      if (c < 0xc0)
+	{
+	  num_chars = num_print = 0;
+	  continue;
+	}
+
+      /* We *might* have a UTF-8 sequence.  Time to start peeking.  */
+      char utf8[4];
+
+      utf8[0] = c;
+      c = get_unicode_byte (stream, putback_buf, & num_putback, & num_read);
+      if (c == EOF)
+	break;
+      utf8[1] = c;
+
+      if ((utf8[1] & 0xc0) != 0x80)
+	{
+	  /* Invalid UTF-8.  */
+	  putback_buf[num_putback++] = utf8[1];
+	  num_chars = num_print = 0;
+	  continue;
+	}
+      else if ((utf8[0] & 0x20) == 0)
+	{
+	  /* A valid 2-byte UTF-8 encoding.  */
+	  if (unicode_display == unicode_invalid)
+	    {
+	      putback_buf[num_putback++] = utf8[1];
+	      num_chars = num_print = 0;
+	    }
+	  else
+	    {
+	      print_buf[num_print ++] = utf8[0];
+	      print_buf[num_print ++] = utf8[1];
+	      num_chars ++;
+	    }
+	  continue;
+	}
+
+      c = get_unicode_byte (stream, putback_buf, & num_putback, & num_read);
+      if (c == EOF)
+	break;
+      utf8[2] = c;
+
+      if ((utf8[2] & 0xc0) != 0x80)
+	{
+	  /* Invalid UTF-8.  */
+	  putback_buf[num_putback++] = utf8[2];
+	  putback_buf[num_putback++] = utf8[1];
+	  num_chars = num_print = 0;
+	  continue;
+	}
+      else if ((utf8[0] & 0x10) == 0)
+	{
+	  /* A valid 3-byte UTF-8 encoding.  */
+	  if (unicode_display == unicode_invalid)
+	    {
+	      putback_buf[num_putback++] = utf8[2];
+	      putback_buf[num_putback++] = utf8[1];
+	      num_chars = num_print = 0;
+	    }
+	  else
+	    {
+	      print_buf[num_print ++] = utf8[0];
+	      print_buf[num_print ++] = utf8[1];
+	      print_buf[num_print ++] = utf8[2];
+	      num_chars ++;
+	    }
+	  continue;
+	}
+
+      c = get_unicode_byte (stream, putback_buf, & num_putback, & num_read);
+      if (c == EOF)
+	break;
+      utf8[3] = c;
+
+      if ((utf8[3] & 0xc0) != 0x80)
+	{
+	  /* Invalid UTF-8.  */
+	  putback_buf[num_putback++] = utf8[3];
+	  putback_buf[num_putback++] = utf8[2];
+	  putback_buf[num_putback++] = utf8[1];
+	  num_chars = num_print = 0;
+	}
+      /* We have a valid 4-byte UTF-8 encoding.  */
+      else if (unicode_display == unicode_invalid)
+	{
+	  putback_buf[num_putback++] = utf8[3];
+	  putback_buf[num_putback++] = utf8[1];
+	  putback_buf[num_putback++] = utf8[2];
+	  num_chars = num_print = 0;
+	}
+      else
+	{
+	  print_buf[num_print ++] = utf8[0];
+	  print_buf[num_print ++] = utf8[1];
+	  print_buf[num_print ++] = utf8[2];
+	  print_buf[num_print ++] = utf8[3];
+	  num_chars ++;
+	}
+    }
+  while (1);
+
+  if (num_chars >= string_min)
+    {
+      /* We know that we have string_min valid characters in print_buf,
+	 and there may be more to come in the stream.  Start displaying
+	 them.  */
+
+      print_filename_and_address (filename, address + start_point);
+
+      unsigned int i;
+      for (i = 0; i < num_print;)
+	{
+	  if (print_buf[i] < 127)
+	    putchar (print_buf[i++]);
+	  else
+	    i += display_utf8_char (print_buf + i);
+	}
+
+      /* OK so now we have to start read unchecked bytes.  */
+
+        /* Find a series of string_min characters.  Put them into print_buf.  */
+      do
+	{
+	  c = get_unicode_byte (stream, putback_buf, & num_putback, & num_read);
+	  if (c == EOF)
+	    break;
+
+	  if (! STRING_ISGRAPHIC (c))
+	    break;
+
+	  if (c < 127)
+	    {
+	      putchar (c);
+	      continue;
+	    }
+
+	  if (c < 0xc0)
+	    break;
+
+	  /* We *might* have a UTF-8 sequence.  Time to start peeking.  */
+	  unsigned char utf8[4];
+
+	  utf8[0] = c;
+	  c = get_unicode_byte (stream, putback_buf, & num_putback, & num_read);
+	  if (c == EOF)
+	    break;
+	  utf8[1] = c;
+
+	  if ((utf8[1] & 0xc0) != 0x80)
+	    {
+	      /* Invalid UTF-8.  */
+	      putback_buf[num_putback++] = utf8[1];
+	      break;
+	    }
+	  else if ((utf8[0] & 0x20) == 0)
+	    {
+	      /* Valid 2-byte UTF-8.  */
+	      if (unicode_display == unicode_invalid)
+		{
+		  putback_buf[num_putback++] = utf8[1];
+		  break;
+		}
+	      else
+		{
+		  (void) display_utf8_char (utf8);
+		  continue;
+		}
+	    }
+
+	  c = get_unicode_byte (stream, putback_buf, & num_putback, & num_read);
+	  if (c == EOF)
+	    break;
+	  utf8[2] = c;
+
+	  if ((utf8[2] & 0xc0) != 0x80)
+	    {
+	      /* Invalid UTF-8.  */
+	      putback_buf[num_putback++] = utf8[2];
+	      putback_buf[num_putback++] = utf8[1];
+	      break;
+	    }
+	  else if ((utf8[0] & 0x10) == 0)
+	    {
+	      /* Valid 3-byte UTF-8.  */
+	      if (unicode_display == unicode_invalid)
+		{
+		  putback_buf[num_putback++] = utf8[2];
+		  putback_buf[num_putback++] = utf8[1];
+		  break;
+		}
+	      else
+		{
+		  (void) display_utf8_char (utf8);
+		  continue;
+		}
+	    }
+
+	  c = get_unicode_byte (stream, putback_buf, & num_putback, & num_read);
+	  if (c == EOF)
+	    break;
+	  utf8[3] = c;
+
+	  if ((utf8[3] & 0xc0) != 0x80)
+	    {
+	      /* Invalid UTF-8.  */
+	      putback_buf[num_putback++] = utf8[3];
+	      putback_buf[num_putback++] = utf8[2];
+	      putback_buf[num_putback++] = utf8[1];
+	      break;
+	    }
+	  else if (unicode_display == unicode_invalid)
+	    {
+	      putback_buf[num_putback++] = utf8[3];
+	      putback_buf[num_putback++] = utf8[2];
+	      putback_buf[num_putback++] = utf8[1];
+	      break;
+	    }
+	  else
+	    /* A valid 4-byte UTF-8 encoding.  */
+	    (void) display_utf8_char (utf8);
+	}
+      while (1);
+
+      if (output_separator)
+	fputs (output_separator, stdout);
+      else
+	putchar ('\n');
+    }
+
+  if (c != EOF)
+    /* FIXME: Using tail recursion here is lazy, but it works.  */
+    print_unicode_stream_body (filename, address + num_read, stream, putback_buf, num_putback, print_buf);
+}
+
+/* Display strings read in from STREAM.  Treat any UTF-8 encoded characters
+   encountered according to the setting of the unicode_display variable.
+   The stream is positioned at ADDRESS and is attached to FILENAME.  */
+
+static void
+print_unicode_stream (const char * filename,
+		      file_ptr     address,
+		      FILE *       stream)
+{
+  /* Paranoia checks...  */
+  if (filename == NULL
+      || stream == NULL
+      || unicode_display == unicode_default
+      || encoding != 'S'
+      || encoding_bytes != 1)
+    {
+      fprintf (stderr, "ICE: bad arguments to print_unicode_stream\n");
+      return;
+    }
+
+  /* Allocate space for string_min 4-byte utf-8 characters.  */
+  unsigned char * print_buf = xmalloc ((4 * string_min) + 1);
+  /* We should never have to put back more than 4 bytes.  */
+  unsigned char putback_buf[5];
+  unsigned int num_putback = 0;
+
+  print_unicode_stream_body (filename, address, stream, putback_buf, num_putback, print_buf);
+  free (print_buf);
+}
 
 /* Find the strings in file FILENAME, read from STREAM.
    Assume that STREAM is positioned so that the next byte read
    is at address ADDRESS in the file.
-   Stop reading at address STOP_POINT in the file, if nonzero.
 
    If STREAM is NULL, do not read from it.
    The caller can supply a buffer of characters
@@ -570,18 +1238,27 @@ static void
 print_strings (const char *filename, FILE *stream, file_ptr address,
 	       int stop_point, int magiccount, char *magic)
 {
+  if (unicode_display != unicode_default)
+    {
+      if (magic != NULL)
+	print_unicode_buffer (filename, address,
+			      (const unsigned char *) magic, magiccount);
+
+      if (stream != NULL)
+	print_unicode_stream (filename, address, stream);
+      return;
+    }
+
   char *buf = (char *) xmalloc (sizeof (char) * (string_min + 1));
 
   while (1)
     {
       file_ptr start;
-      int i;
+      unsigned int i;
       long c;
 
       /* See if the next `string_min' chars are all graphic chars.  */
     tryline:
-      if (stop_point && address >= stop_point)
-	break;
       start = address;
       for (i = 0; i < string_min; i++)
 	{
@@ -718,6 +1395,8 @@ usage (FILE *stream, int status)
   -T --target=<BFDNAME>     Specify the binary file format\n\
   -e --encoding={s,S,b,l,B,L} Select character size and endianness:\n\
                             s = 7-bit, S = 8-bit, {b,l} = 16-bit, {B,L} = 32-bit\n\
+  --unicode={default|show|invalid|hex|escape|highlight}\n\
+  -U {d|s|i|x|e|h}          Specify how to treat UTF-8 encoded unicode characters\n\
   -s --output-separator=<string> String used to separate strings in output.\n\
   @<file>                   Read options from <file>\n\
   -h --help                 Display this information\n\
Only in binutils-2.35.2/binutils/: sysinfo
Only in binutils-2.35.2/binutils/: sysinfo.o
Only in binutils-2.35.2/binutils/: syslex_wrap.o
Only in binutils-2.35.2/binutils/: sysroff.h
Only in binutils-2.35.2/binutils/: version.o
